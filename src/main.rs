/*
 * Part of mlat-client-rust (https://github.com/tjmullicani/mlat-client-rust) - an ADS-B multilateration client.
 * Based on mlat-client (https://github.com/mutability/mlat-client)
 * Copyright 2023, Timothy Mullican <timothy.j.mullican@gmail.com>
 * Copyright 2015, Oliver Jowett <oliver@mutability.co.uk>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * References:
 *   https://github.com/firestuff/adsb-tools/blob/master/protocols/beast.md
 *   https://github.com/wiseman/java-mode-s-beast/blob/master/src/main/java/com/lemondronor/modesbeast/BeastMessageParser.java
 *   https://github.com/junzis/sil/blob/master/stream/base.py
 *   https://thepythoncode.com/assistant/code-converter/c/rust/
 */

use std::collections::HashSet;
use std::collections::HashMap;
use std::time::{SystemTime, Duration};
use std::net::{TcpStream, SocketAddr, TcpListener};
use hex_slice::AsHex;
use std::error::Error;
use std::fmt;
use std::io::Cursor;
use std::io::ErrorKind;
use log::{error, warn, info, debug, trace};
use rustc_serialize::hex::ToHex;
use hex;
use std::thread;
use std::io::{self, BufRead, BufReader, Read, Write};

mod modes;

use crate::modes::modes::*;
use crate::modes::modes_crc::*;

/* decoder modes */
#[derive(Eq, PartialEq, Clone, Debug)]
enum DecoderMode {
    Beast,             /* Beast binary, freerunning 48-bit timestamp @ 12MHz */
    Radarcape,         /* Beast binary, 1GHz Radarcape timestamp, UTC synchronized from GPS */
    RadarcapeEmulated, /* Beast binary, 1GHz Radarcape timestamp, not synchronized */
    Avr,               /* AVR, no timestamp */
    Avrmlat,           /* AVR, freerunning 48-bit timestamp @ 12MHz */
    Sbs,               /* Kinetic SBS, freerunning 20MHz 24-bit timestamp, wraps around all the time but we try to widen it */
    None,              /* Not configured */
}

const BEAST_ESCAPE: u8               = 0x1A;
// message types
const MESSAGE_TYPE_AC: u8            = 0x31; // '1'
const MESSAGE_TYPE_MODE_S: u8        = 0x32; // '2'
const MESSAGE_TYPE_MODE_L: u8        = 0x33; // '3'
const MESSAGE_TYPE_RADARCAPE: u8     = 0x34; // '4'
const MESSAGE_TYPE_RADARCAPE_POS: u8 = 0x35; // '5'

// This range of timestamps are treated as synthetic messages (generated by mlat, from UAT, etc)
const SYNTHETIC_TIMESTAMP_START: u64 = 0xFF004D4C4154;
const SYNTHETIC_TIMESTAMP_END: u64 = SYNTHETIC_TIMESTAMP_START + 10;

/* a ModesReader object */
#[derive(Debug)]
pub struct ModesReader {
    /* decoder characteristics */
    decoder_mode: DecoderMode,
    decoder_mode_string: String,
    buffer: HashSet<Vec<u8>>,
    frequency: u64,
    epoch: String,
    last_timestamp: u64, /* last seen timestamp */
    radarcape_utc_bugfix: u32,

    /* configurable bits */
    allow_mode_change: bool,
    want_zero_timestamps: bool,
    want_mlat_messages: bool,
    want_invalid_messages: bool,
    want_events: bool,
    
    /* filtering */
    seen: HashSet<i32>,
    default_filter: Option<[i32; 32]>,
    specific_filter: Vec<Option<bool>>,
    modeac_filter: HashMap<String, String>,

    /* stats */
    received_messages: u32,
    suppressed_messages: u32,
}

// Constructs a new `ModesReader`.
impl Default for ModesReader {
    fn default() -> ModesReader {
        ModesReader {
            /* minimal init */
            decoder_mode: DecoderMode::None,
            decoder_mode_string: String::from(""),
            buffer: HashSet::new(),
            frequency: 0,
            epoch: String::from(""),
            last_timestamp: 0,
            radarcape_utc_bugfix: 0,
            allow_mode_change: true,
            want_zero_timestamps: false,
            want_mlat_messages: false,
            want_invalid_messages: false,
            want_events: true,
            seen: HashSet::new(),
            default_filter: None,
            specific_filter: vec![None; 32],
            modeac_filter: HashMap::new(),
            received_messages: 0,
            suppressed_messages: 0,
        }
    }
}
impl ModesReader {
    fn new(
        decoder_mode: DecoderMode,
        decoder_mode_string: String,
        buffer: HashSet<Vec<u8>>,
        frequency: u64,
        epoch: String,
        last_timestamp: u64, /* last seen timestamp */
        radarcape_utc_bugfix: u32,
        allow_mode_change: bool,
        want_zero_timestamps: bool,
        want_mlat_messages: bool,
        want_invalid_messages: bool,
        want_events: bool,
        seen: HashSet<i32>,
        default_filter: Option<[i32; 32]>,
        specific_filter: Vec<Option<bool>>,
        modeac_filter: HashMap<String, String>,
        received_messages: u32,
        suppressed_messages: u32,
    ) -> Self {
        ModesReader { 
            decoder_mode,
            decoder_mode_string,
            buffer,
            frequency,
            epoch,
            last_timestamp,
            radarcape_utc_bugfix,
            allow_mode_change,
            want_zero_timestamps,
            want_mlat_messages,
            want_invalid_messages,
            want_events,
            seen,
            default_filter,
            specific_filter,
            modeac_filter,
            received_messages,
            suppressed_messages,
        }
    }

    fn set_decoder_mode(&mut self, newmode: DecoderMode) {
        self.decoder_mode = newmode.clone();
        match newmode {
            DecoderMode::Beast => {
                self.frequency = 12_000_000u64; // assumed
                self.epoch = String::from("");
            },
            DecoderMode::Radarcape => {
                self.frequency = 1_000_000_000u64;
                self.epoch = String::from("utc_midnight");
            },
            DecoderMode::RadarcapeEmulated => {
                self.frequency = 1_000_000_000u64;
                self.epoch = String::from("");
            },
            DecoderMode::Avrmlat => {
                self.frequency = 12_000_000u64; // assumed
                self.epoch = String::from("");
            },
            DecoderMode::Sbs => {
                self.frequency = 20_000_000u64;
                self.epoch = String::from("");
            },
            DecoderMode::Avr | _ => {
                self.frequency = 0;
                self.epoch = String::from("");
            },
        }
    }

   // TODO
   /* feed some data to the reader and does one of:
    *  1) returns a tuple (bytes_consumed, messages, error_pending), or
    *  2) throws an exception
    *
    * If a stream error is seen, but some messages were parsed OK,
    * then an exception is not immediately thrown and the parsed
    * messages are returned with error_pending = true. The caller
    * should call feed again (after consuming the given number of
    * bytes) to get the exception.
    *
    * Internal errors (e.g. out of memory) are thrown immediately.
    */
    /*pub fn feed(&mut self) -> ??? {
        let buffer: PyBuffer;
        let mut rv: Option<PyObject> = None;
        let mut max_messages = 0;
        let kwlist = ["buffer", "max_messages"];

        match self.decoder_mode {
            DecoderMode::None => {
                return Err("decoder mode is None, no decoder type selected");
            }
            DecoderMode::Beast | DecoderMode::Radarcape | DecoderMode::RadarcapeEmulated => {
                rv = Some(feed_beast(self, &buffer, max_messages)?);
            }
            DecoderMode::Avr | DecoderMode::Avrmlat => {
                rv = Some(feed_avr(self, &buffer, max_messages)?);
            }
            DecoderMode::Sbs => {
                rv = Some(feed_sbs(self, &buffer, max_messages)?);
            }
            _ => {
                return Err("decoder somehow got into illegal mode {}");
            }
        }
        rv
    }*/

    /// Parses a Beast binary message from a reader.
    ///
    /// # Arguments
    ///
    /// * `reader` - A reader that implements the `Read` trait.
    ///
    /// # Returns
    ///
    /// This function returns a `Result` containing a `BeastMessage` if successful,
    /// or an `io::Error` if an error occurs during reading.
    //fn beast(&mut self, buffer: ???, max_messages: i32) -> ??? {
    //pub fn feed_beast(&mut self) -> (i64, (), bool) {
    pub fn feed_beast(&mut self) -> io::Result<BeastMessage> {
        let mut timestamp: u64 = 0;
        let mut timestamp_bytes: [u8; 6] = [0; 6];
        let mut signal: u8 = 0;
        let mut m_type: u8 = 0;
        let mut message_tuple: () = ();
        let mut message_count: i32 = 0;
        let buffer_start: u8 = 0;
        let p: u8 = 0;
        let eod: u8 = 0;
        let error_pending: bool = false;

        for message in self.buffer.iter() {
            debug!("feed_beast: ");
            debug!("feed_beast: --- NEW START OF FRAME ---");
            debug!("feed_beast: frame = {:#02X}", message.as_hex());
            let mut reader = &message[..];

            // Read the start-of-message byte (BEAST_ESCAPE)
            let mut buffer = [0; 1];
            reader.read_exact(&mut buffer)?;
            //reader.read_exact(&mut buffer).expect("read buffer failed");
            if buffer[0] != BEAST_ESCAPE {
                error!("Lost sync with input stream: expected {} but found {:#02X} instead", BEAST_ESCAPE, buffer[0]);
                return Err(io::Error::new(io::ErrorKind::InvalidData, "Lost sync with input stream: expected a BEAST_ESCAPE marker")); //unsure about offset value
            }

            // Read the second byte to determine the message type
            let message_type = match read_byte(&mut reader)? {
                MESSAGE_TYPE_AC            => '1', // Mode-AC
                MESSAGE_TYPE_MODE_S        => '2', // Mode-S Short
                MESSAGE_TYPE_MODE_L        => '3', // Mode-S Long
                MESSAGE_TYPE_RADARCAPE     => '4', // ADS-B
                _                          => {
                    error!("Received unknown message type");
                    return Err(io::Error::new(ErrorKind::InvalidData, "Received unknown message type"));
                },
            };
            let message_length = match message_type as u8 {
                MESSAGE_TYPE_AC            => 2,  // mode A/C
                MESSAGE_TYPE_MODE_S        => 7,  // mode S short
                MESSAGE_TYPE_MODE_L        => 14, // mode S long
                MESSAGE_TYPE_RADARCAPE     => 14, // radarcape status message
                MESSAGE_TYPE_RADARCAPE_POS => 21, // radarcape position message, no timestamp/signal bytes
                _                          => {
                    error!("Lost sync with input stream: unexpected message type {:#02X} after {}", message_type as u8, BEAST_ESCAPE);
                    return Err(io::Error::new(io::ErrorKind::InvalidData, "Lost sync with input stream: unexpected message type after BEAST_ESCAPE")); // unsure about offset value
                },
            };
            debug!("feed_beast: message_type = {}", message_type as char);
            debug!("feed_beast: message_length = {}", message_length);
            let has_timestamp_signal = if message_type as char == '5' { false } else { true };
            debug!("feed_beast: has_timestamp_signal = {}", has_timestamp_signal);

            if has_timestamp_signal {
                // Read the timestamp (6 bytes)
                //let mut timestamp_bytes = [0; 6];
                reader.read_exact(&mut timestamp_bytes)?;
                //for byte in timestamp_bytes.iter_mut() {
                //    *byte = read_byte(reader)?;
                //}

                for i in 0..6 {
                    trace!("feed_beast: timestamp_bytes[{}] = {:#02X}", i, timestamp_bytes[i]);
               }

                timestamp = u64::from_be_bytes([
                    0, 0, // Pad to 8 bytes
                    timestamp_bytes[0],
                    timestamp_bytes[1],
                    timestamp_bytes[2],
                    timestamp_bytes[3],
                    timestamp_bytes[4],
                    timestamp_bytes[5],
                ]);
                debug!("feed_beast: timestamp = {}", timestamp);

                // Read the signal level (1 byte)
                signal = read_byte(&mut reader)?;
                debug!("feed_beast: signal = {:#02X}", signal);
            }

            // Read the message payload (variable length)
            //let mut message = read_bytes(&mut reader, message_length);
            // Attempt to read bytes into the message buffer
            let message = match read_bytes(&mut reader, message_length) {
                Ok(bytes) => bytes,
                Err(err) => {
                    warn!("Error reading message: {}", err);
                    Vec::new() // Provide a default value or an empty buffer
                }
            };
            
            debug!("feed_beast: message  = {:#02X}", message.as_hex());
            //trace!("feed_beast: checksum = {:#02X}", checksum(&message, None));
            debug!("feed_beast: message checksum valid = {}", checksum_compare(&message, None));
            //assert_eq!(checksum_compare(&message, None), true);

            if checksum_compare(&message, None) {
                self.received_messages += 1;
            }

/////////////////////////////////////////////////////////////////////
            // do some filtering

            /*if m_type as char == '4' {
                /* radarcape-style status message, use this to switch our decoder type */

                self.radarcape_utc_bugfix = (timestamp_bytes[0] & 0x80) == 0x80; //verify timestamp_bytes[0] == data[2]

                if self.allow_mode_change {
                    let newmode: DecoderMode = newmode.clone();
                    if message_type & 0x10 { // verify message_type == data[0]
                        /* radarcape in GPS timestamp mode */
                        if (timestamp_bytes[0] & 0x20) == 0x20 { // verify timestamp_bytes[0] == data[2]
                            newmode = DecoderMode::RadarcapeEmulated;
                        } else {
                            newmode = DecoderMode::Radarcape;
                        }
                    } else {
                        /* radarcape in 12MHz timestamp mode */
                        newmode = DecoderMode::Beast;
                    }

                    /* handle mode changes by inserting an event message */
                    if newmode != self.decoder_mode {
                        self.set_decoder_mode(newmode);
                        if self.want_events {
                            //if ! (messages[message_count++] = make_mode_change_event(self))
                            if !self.messages[message_count] = self.make_mode_change_event() {
                                message_count += 1;
                            }
                            // goto out;
                        }
                    }
                }
            }

            if has_timestamp_signal && !self.is_synthetic_or_zero_timestamp(timestamp) {
                if self.decoder_mode == DecoderMode::Beast {
                    /* 12MHz mode */

                    /* check for very out of range value
                     * (dump1090 can hold messages for up to 60 seconds! so be conservative here)
                     * also work around dump1090-mutability issue #47 which can send very stale Mode A/C messages
                     */
                    if self.want_events && m_type as char != '1' && !self.timestamp_check(timestamp) {
                        if !messages[message_count] = self.make_timestamp_jump_event(timestamp) {
                            message_count += 1;
                            // goto out;
                        }
                    }

                    /* adjust the timestamps so they always reflect the start of the frame */
                    let adjust: u64;
                    if m_type as char == '1' {
                        // Mode A/C, timestamp reported at F2 which is 20.3us after F1
                        // this is 243.6 cycles at 12MHz
                        adjust = 244;
                    } else if m_type as char == '2' {
                        // Mode S short, timestamp reported at end of frame, frame is 8us preamble plus 56us data
                        // this is 768 cycles at 12MHz
                        adjust = 768;
                    } else if m_type as char == '3' {
                        // Mode S long, timestamp reported halfway through the frame (at bit 56), same offset as Mode S short
                        adjust = 768;
                    } else {
                        // anything else we assume is already correct
                        adjust = 0;
                    }

                    if timestamp < adjust {
                        timestamp = 0;
                    } else {
                        timestamp = timestamp - adjust;
                    }
                } else {
                    /* gps mode */

                    /* adjust timestamp so that it is a contiguous nanoseconds-since-
                     * midnight value, rather than the raw form which skips values once
                     * a second
                     */
                    let nanos: u64 = timestamp & 0x00003FFFFFFF;
                    let secs: u64 = timestamp >> 30;

                    if !self.radarcape_utc_bugfix {
                        /* fix up the timestamp so it is UTC, not 1 second ahead */
                        if secs == 0 {
                            secs = 86399;
                        } else {
                            --secs;
                        }
                    }

                    timestamp = nanos + secs * 1000000000;

                    /* adjust the timestamps so they always reflect the start of the frame */
                    let adjust: u64;
                    if m_type as char == '1' {
                        // Mode A/C, timestamp reported at F2 which is 20.3us after F1
                        adjust = 20300;
                    } else if m_type as char == '2' {
                        // Mode S short, timestamp reported at end of frame, frame is 8us preamble plus 56us data
                        adjust = 64000;
                    } else if m_type as char == '3' {
                        // Mode S long, timestamp reported at end of frame, frame is 8us preamble plus 112us data
                        adjust = 120000;
                    } else {
                        // anything else we assume is already correct
                        adjust = 0;
                    }

                    if adjust <= timestamp {
                        timestamp = timestamp - adjust;
                    } else {
                        /* wrap it to the previous day */
                        timestamp = timestamp + 86400 * 1_000_000_000 - adjust;
                    }

                    /* check for end of day rollover */
                    if self.want_events && self.last_timestamp >= 86340 * 1_000_000_000 && timestamp <= 60 * 1_000_000_000 {
                        if !messages[message_count] = make_epoch_rollover_event(timestamp) {
                            message_count += 1;
                            // goto out;
                        }
                    } else if self.want_events && m_type as char != '1' && !timestamp_check(timestamp) {
                        if !messages[message_count] = make_epoch_jump_event(timestamp) {
                            message_count += 1;
                            // goto out;
                        }
                    }
                }

                if m_type as char != '1' {
                    self.timestamp_update(timestamp);
                }
            }

            if m_type as char == '4' {
                /* radarcape-style status message, emit the status event if wanted */
                if self.want_events {
                    if !messages[message_count] = self.make_radarcape_status_event(timestamp, data) {
                        message_count += 1;
                        // goto out;
                    }
                }

                /* don't try to process this as a Mode S message */
                p = m;
                continue;
            }

            if m_type as char == '5' {
                /* radarcape-style position message, emit the position event if wanted */

                if self.want_events {
                    if !messages[message_count] = self.make_radarcape_position_event(data) {
                        message_count += 1;
                        // goto out;
                    }
                }

                /* don't try to process this as a Mode S message */
                p = m;
                continue;
            }

            /* it's a Mode A/C or Mode S message, parse it */
            if !(message = modesmessage_from_buffer(timestamp, signal, data, message_len)) {
                // goto out;
            }

            /* apply filters, update seen-set */
            self.received_messages += 1;
            wanted = self.filter_message(message);
            if wanted < 0 {
                // goto out;
            } else if wanted {
                messages[message_count] = message;
                message_count += 1;
            } else {
                self.suppressed_messages += 1;
            }

            p = m;*/
        }

        //if !(message_tuple = PyTuple_New(message_count)) {
        // goto out;
        //}

    //while message_count >= 0 {
        //PyTuple_SET_ITEM(message_tuple, message_count, messages[message_count]); /* steals ref */
        //message_tuple.set_item(message_count, messages[message_count]);
    //    message_count -= 1;
    //}

    //rv = Py_BuildValue("(l,N,N)", (long) (p - buffer_start), message_tuple, PyBool_FromLong(error_pending));
    //let rv = ((p as usize - buffer_start as usize) as i64, message_tuple, error_pending);

    //return rv;
/////////////////////////////////////////////////////////////////////


        let message_length = 0;
        let timestamp = 0;
        let signal_level = 0;
        let message: Vec<u8> = Vec::new();
        Ok(BeastMessage {
            message_length,
            timestamp,
            signal_level,
            message,
        })
    }

    /*
    pub fn timestamp_update(&mut self, timestamp: u64) {
        if self.is_synthetic_or_zero_timestamp(timestamp) {
            // special timestamps, don't use them
            return;
        }

        if self.last_timestamp == 0 || self.frequency == 0 {
            self.last_timestamp = timestamp;
            return ;
        }

        if self.last_timestamp > timestamp && (self.last_timestamp - timestamp) < 90 * self.frequency {
            // ignore small moves backwards
            return;
        }

        if (self.decoder_mode == DecoderMode::Radarcape || self.decoder_mode == DecoderMode::RadarcapeEmulated) &&
            timestamp >= 86340 * 1000000000 && self.last_timestamp <= 60 * 1000000000 {
                // in radarcape mode, don't allow last_timestamp to roll back to the previous day
                // as we will have already issued an epoch reset
                return;
        }

        self.last_timestamp = timestamp;
    }
    
    pub fn make_radarcape_position_event(&mut self, data: u8) {
        let eventdata = self.radarcape_position_to_dict(data);

        return modesmessage_new_eventmessage(DF_EVENT_RADARCAPE_POSITION, 0, eventdata);
    }

    pub fn is_synthetic_or_zero_timestamp(&mut self, timestamp: u64) -> bool {
        return timestamp == 0 || self.is_synthetic_timestamp(timestamp);
    }

    pub fn is_synthetic_timestamp(&mut self, timestamp: u64) -> bool {
        return timestamp >= SYNTHETIC_TIMESTAMP_START && timestamp <= SYNTHETIC_TIMESTAMP_END;
    }

    pub fn radarcape_position_to_dict(&mut self, data: &[u8]) -> HashMap<String, f32> {
        let lat = f32::from_le_bytes(data[4..8].try_into().unwrap());
        let lon = f32::from_le_bytes(data[8..12].try_into().unwrap());
        let alt = f32::from_le_bytes(data[12..16].try_into().unwrap());

        let mut map = HashMap::new();
        map.insert("lat".to_string(), lat);
        map.insert("lon".to_string(), lon);
        map.insert("alt".to_string(), alt);

        map
    }

    /* inspect a message, update the seen set
    * return 1 if we should pass this message on to the caller
    * return 0 if we should drop it
    * return -1 on internal error (exception has been raised)
    */
    pub fn filter_message(&mut self, message: &ModesMessage) -> i32 {
        if message.df == DF_MODEAC {
            if let Some(modeac_filter) = &self.modeac_filter {
                return modeac_filter.contains(&message.address) as i32;
            }
            return 1;
        }

        if !message.valid {
            return self.want_invalid_messages as i32;
        }

        if let Some(seen) = &self.seen {
            if [11, 17, 18].contains(&message.df) && seen.insert(message.address.clone()) {
                return -1;
            }
        }

        if message.timestamp == 0 && !self.want_zero_timestamps {
            return 0;
        }

        if self.is_synthetic_timestamp(message.timestamp) && !self.want_mlat_messages {
            return 0;
        }

        if self.default_filter.is_none() && self.specific_filter.is_none() {
            return 1;
        }

        if let Some(entry) = self.default_filter.as_ref().and_then(|filter| filter.get(&message.df)) {
            return entry.is_true() as i32;
        }

        if let Some(entry) = self.specific_filter.as_ref().and_then(|filter| filter.get(&message.df)) {
            return entry.map_or(0, |entry| entry.contains(&message.address) as i32);
        }

        0
    }

    fn make_mode_change_event(&mut self) -> HashMap<&str, t> {
        let mut eventdata = HashMap::new();
        eventdata.insert("mode", EventData::Mode(self.decoder_mode.clone()));
        eventdata.insert("frequency", EventData::Frequency(self.frequency));
        eventdata.insert("epoch", EventData::Epoch(self.epoch.clone()));

        eventdata
    }*/
}

#[derive(Debug)]
enum EventData {
    Mode(DecoderMode),
    Frequency(u64),
    Epoch(String),
}

/// Represents a parsed ADS-B message with minimal fields.
struct AdsbMessage {
    msg_type: u8,
    timestamp: u64,
    signal_level: u8,
    mode_s_data: Vec<u8>,
}

/// Represents a Mode-S Beast binary message.
#[derive(Debug)]
pub struct BeastMessage {
    pub message_length: usize,
    pub timestamp: u64,
    pub signal_level: u8,
    pub message: Vec<u8>,
}

// Decoder reads a Beast stream and stores individual frames.
struct Decoder {
    strip_escape: bool,
    buf: Vec<u8>,
    message: Message,
    timestamp: u64,
    signal_level: u8,
}

//  Consider replacing with tuple
//  pub struct Message(usize, u8, Vec<u8>);
//  The struct is replaced with a tuple struct, which directly contains the fields without the need for explicit field names.
//  The fields are ordered as (message_length, message_type, message), matching the original struct's fields.
struct Message {
    message_length: usize,
    message_type: u8,
    message: Vec<u8>,
}

impl Message {
    fn new() -> Self {
        Message {
            message_length: 0,
            message_type: 0,
            message: vec![],
        }
    }
}

/// Reads a byte from the reader, handling the escape sequence for BEAST_ESCAPE.
///
/// # Arguments
///
/// * `reader` - A reader that implements the `Read` trait.
///
/// # Returns
///
/// This function returns a `Result` containing the read byte, or an `io::Error` if an error occurs.
fn read_byte<R: Read>(reader: &mut R) -> io::Result<u8> {
    let mut buffer = [0; 1];
    reader.read_exact(&mut buffer)?;

    if buffer[0] == BEAST_ESCAPE {
        // Check if it's an escape sequence
        let mut temp_buffer = [0; 1];
        if reader.read_exact(&mut temp_buffer).is_ok() && temp_buffer[0] == BEAST_ESCAPE {
            trace!("read_byte: is escape sequence. returning byte {}", BEAST_ESCAPE);
            Ok(BEAST_ESCAPE) // It's an escape sequence, return the true BEAST_ESCAPE value
        } else {
            trace!("read_byte: is NOT escape sequence. returning byte {:#02X}", buffer[0]);
            Ok(buffer[0]) // Not an escape sequence, return the original BEAST_ESCAPE 
        }
    } else {
        Ok(buffer[0]) // Return the read byte
    }
}

/// Reads a specified number of bytes from the reader, handling the optional escape sequence for BEAST_ESCAPE.
///
/// # Arguments
///
/// * `reader` - A reader that implements the `Read` trait.
/// * `length` - The number of bytes to read.
///
/// # Returns
///
/// This function returns a `Result` containing a vector of bytes if successful,
/// or an `io::Error` if an error occurs during reading.
fn read_bytes<R: Read>(reader: &mut R, length: usize) -> io::Result<Vec<u8>> {
    let mut result: Vec<u8> = Vec::with_capacity(length);

    for _ in 0..length {
        let mut buffer = [0; 1];
        reader.read_exact(&mut buffer)?;

        if buffer[0] == BEAST_ESCAPE {
            let mut temp_buffer = [0; 1];
            if reader.read_exact(&mut temp_buffer).is_ok() && temp_buffer[0] == BEAST_ESCAPE {
                trace!("read_bytes: is escape sequence. returning byte {}", BEAST_ESCAPE);
                result.push(BEAST_ESCAPE); // It's an escape sequence, add the true 0x1a value to the result
            } else {
                trace!("read_bytes: is NOT escape sequence. return bytes {:#02X} {:#02X}", buffer[0], temp_buffer[0]);
                result.push(buffer[0]); // Not an escape sequence, add the byte to the result
                result.push(temp_buffer[0]);
            }
        } else {
            result.push(buffer[0]); // Not BEAST_ESCAPE, add the byte to the result
        }
    }

    Ok(result)
}

/// Handles a single TCP connection
///
/// # Arguments
///
/// * `stream` - The TCP stream to read data from
fn handle_connection(stream: &mut TcpStream) -> io::Result<()> {
    // Wrap the stream in a BufReader, so we can use the BufRead methods
    //let mut reader = BufReader::with_capacity(10000, stream);
    let mut reader = BufReader::new(stream);

    loop {
        // Read current data in the TcpStream
        let received: Vec<u8> = reader.fill_buf()?.to_vec();

        // If no data is received, the connection might have been closed
        if received.is_empty() {
            println!("No data received. Connection might be closed.");
            break;
        }

        // Mark the bytes read as consumed so the buffer will not return them in a subsequent read
        reader.consume(received.len());

        let frame_locations = find_frame_starts(&received);
        trace!("handle_connection: frame_locations.len() = {}", frame_locations.len());
        let beast_messages: HashSet<Vec<u8>> = frame_locations
            .iter()
            .map(|(start_index, end_index)| received[*start_index..*end_index].to_vec())
            .collect();

        let mut mode = ModesReader::default();
        mode.set_decoder_mode(DecoderMode::Beast);
        mode.buffer = beast_messages.clone();
        match mode.feed_beast() {
            Ok(o) => {},
            Err(e) => error!("handle_connection: {}", e),
        }
        warn!("Extracted {} messages", mode.received_messages);
    }
    

    Ok(())
}

fn find_frame_starts(data: &[u8]) -> Vec<(usize, usize)> {
    trace!("find_frame_starts: data.len() = {}", data.len());
    let mut frames = Vec::new();
    let mut i = 0;

    while i < data.len() {
        trace!("find_frame_start: data[i] = {:#02X}", data[i]);
        if i + 2 < data.len() && data[i] != BEAST_ESCAPE && data[i + 1] == BEAST_ESCAPE && (data[i + 2] == 0x31 || data[i + 2] == 0x32 || data[i + 2] == 0x33) {
            trace!("find_frame_starts: i         = {}",      i);
            trace!("find_frame_starts: data[i]   = {:#02X}", data[i]); 
            trace!("find_frame_starts: data[i+1] = {:#02X}", data[i+1]); 
            trace!("find_frame_starts: data[i+2] = {:#02X}", data[i+2]); 
            let start_index = i + 1; // advance to start of frame marked by BEAST_ESCAPE
            let mut end_index = i + 2;
            while end_index + 2 < data.len() && !(data[end_index] == BEAST_ESCAPE && (data[end_index + 1] == 0x31 || data[end_index + 1] == 0x32 || data[end_index + 1] == 0x33)) {
                end_index += 1;
            }
            if end_index < data.len() {
                frames.push((start_index, end_index));
                i = end_index;
            } else {
                break;
            }
        } else {
            i += 1;
        }
    }
    frames
}

fn main() {
    env_logger::init();

    let mut mode = ModesReader::default();
    mode.set_decoder_mode(DecoderMode::Beast);

    // In this version, the parse_beast_format function takes a reference to a HashSet<Vec<u8>> where each Vec<u8> represents a Beast format message. The function iterates over the HashSet, attempting to parse each Vec<u8> as a message, and collects successfully parsed messages into a Vec<AdsbMessage>. The main function demonstrates how to use this function with a dummy HashSet containing two Beast messages.
    // Example usage of the `parse_beast_format` function
    // Create a dummy HashSet with Beast format message bytes
    //let mut beast_messages = HashSet::new();
    //beast_messages.insert(message);

    // Parse the Beast format messages
    // let parsed_messages = beast(&beast_messages);

    //for adsb_msg in beast_messages {
        /*println!("Parsed ADS-B Message:");
        println!("Message Type: {}", adsb_msg.msg_type);
        println!("ICAO Address: {:06X}", adsb_msg.icao_address);
        println!("Payload: {:?}", adsb_msg.payload);*/
        // Parse the Beast format message
        //let m: Vec<(String, SystemTime)> = beast(&adsb_msg);
        //println!("Parsed ADS-B Message:");
        //println!("{:?}", m);
        //println!("MSG Type: {}", m.msg_type);
        //println!("Timestamp: {}", m.timestamp);
        //println!("Signal Level: {:04X}", m.signal_level);
        //println!("Mode-S Data: {:?}", m.mode_s_data);
        //for bit in m.mode_s_data {
        //    println!("{:x}", bit);
        //}
    //}

    // Create a new BeastStream instance
    /*let host = String::from("example.com");
    let port = 1234;
    let df_filter = Some(vec![0x31, 0x32, 0x33]);  // Example filter
    let buff_size = 1024;
    let output_dir = Some(String::from("/path/to/output"));
    let mut beast_stream = BeastStream::new(host, port, df_filter, buff_size, output_dir);

    // Simulate receiving a buffer of data
    let mut buffer: Vec<u8> = vec![0x1A, 0x32, 0x08, 0x3E, 0x27, 0xB6, 0xCB, 0x6A, 0x1A, 0x1A, 0x00, 0xA1, 0x84, 0x1A, 0x1A, 0xC3, 0xB3, 0x1D];
    beast_stream.base_stream.buffer = buffer;

    // Process the buffer and extract messages
    let messages = beast_stream.read_message_in_buffer();

    // Print the extracted messages and their timestamps
    for (msg, ts) in messages {
        println!("Received message: {:?}, Timestamp: {:?}", msg, ts);
    }

    // Example usage: parse a Beast message from a byte slice.
    // This byte slice should be replaced with actual data from a Beast receiver.
    let data = vec![
        0x1A, // Message start
        0x33, // Message type: Mode-S Long
        0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, // MLAT Timestamp
        0xFF, // Signal level
        // Mode-S Long message payload (14 bytes)
        0x8D, 0x48, 0x40, 0xD6, 0x20, 0x2C, 0x4B, 0x8E, 0x57, 0x60, 0x98, 0x3B, 0x56, 0x2D,
    ];
    let mut reader = &data[..];
    let beast_message = parse_beast_message(&mut reader).unwrap();
    println!("Parsed Beast message: {:?}", beast_message);
    */

    //////////////////// BEAST VALIDATION SECTION
    /*
    let mut data: Vec<u8>;
    data = vec![
        0x1A, // Message start
        0x32, // Message type: Mode-S Short
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, // MLAT timestamp
        0xFF, // Signal level
        // Mode-S Short data (7 bytes)
        0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97
    ];
    beast_messages.insert(data);
    mode.buffer = beast_messages.clone();
    mode.feed_beast();
    */

    //assert_eq!(mode.message, [0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97]);
    //assert_eq!(mode.signal, 0xFF); //TODO
    //assert_eq!(mode.parity, true); //TODO

    // Validate the checksum of the frame
    //let is_valid = validate_checksum_short(&[0x8D, 0x48, 0x50, 0x15, 0x22, 0x37, 0x56]); // Mode-S Short message
    //let is_valid = validate_checksum_long(&[0x8D, 0x48, 0x40, 0xD6, 0x20, 0x2C, 0xC3, 0x71, 0xC3, 0x2C, 0xE0, 0x57, 0x60, 0x98]); // Mode-S Long message
    //let mut msg: [u32; 4] = [
    //    0x8D4840D6,
    //    0x202CC371,
    //    0xC32CE057,
    //    0x6098, // Note: This is the last 16 bits of the message, the last 8 bits are assumed to be 0
    //];
    //let mut msg: Vec<u8> = vec![
        //0x8D, 0x48, 0x40, 0xD6,
        //0x20, 0x2C, 0xC3, 0x71,
        //0xC3, 0x2C, 0xE0, 0x57,
        //0x60, 0x98 // Note: This is the last 16 bits of the message, the last 8 bits are assumed to be 0
    //];
    // Calculate the checksum
    //calculate_checksum(&mut msg);
    // Check if the message is corrupted
    //let corrupted = is_msg_corrupted(&msg);
    // Output the result
    //println!("The message is {}", if corrupted { "corrupted" } else { "not corrupted" });

    //data = vec![
    //
    //];
    //beast_messages.insert(data);
    //mode.buffer = beast_messages.clone();
    //mode.feed_beast();
    //assert_eq!(mode.message, [0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27]);
    //assert_eq!(mode.signal, 0x

    /*
    // Test escape discard error
    let mut data: Vec<u8>;
    data = vec![
        0x1a, // Message start
        0x31, // Message type: AC
        0x1a, 0x1a, 0x1a // MLAT timestamp
    ];
    //let mut reader = &data[..];
    //let beast_message = mode.parse_beast_message(&mut reader);
    //assert_eq!(beast_message.unwrap_err().to_string(), "failed to fill whole buffer");

    // Test read unread error
    data = vec![
        0x1a, // Message start
        0x31, // Message type: AC
        0x1a, // MLAT timestamp
    ];
    let mut reader = &data[..];
    let beast_message = mode.parse_beast_message(&mut reader);
    assert_eq!(beast_message.unwrap_err().to_string(), "failed to fill whole buffer");

    // Test after seek discard error
    data = vec![
        0xff, 0xff, 0xff, 0xff, 0x1a, 0x31, 0x1a, 0x31
    ];
    let mut reader = &data[..];
    let beast_message = mode.parse_beast_message(&mut reader);
    assert_eq!(beast_message.unwrap_err().to_string(), "Lost sync with input stream: expected a 0x1A marker");

    // Test after seek peek error
    data = vec![
        0xff, 0xff, 0xff, 0xff, 0x1a, 0x31
    ];
    let mut reader = &data[..];
    let beast_message = mode.parse_beast_message(&mut reader);
    assert_eq!(beast_message.unwrap_err().to_string(), "Lost sync with input stream: expected a 0x1A marker");

    // Test seek peek error
    data = vec![
        0xff, 0xff, 0xff
    ];
    let mut reader = &data[..];
    let beast_message = mode.parse_beast_message(&mut reader);
    assert_eq!(beast_message.unwrap_err().to_string(), "Lost sync with input stream: expected a 0x1A marker");

    // Test with signal level NOT escaped
    data = vec![
        0x1A, // Message start
       0x32, // Message type: Mode-S Short
        0x08, 0x3e, 0x27, 0xb6, 0xcb, 0x6a, // MLAT timestamp
        0x1b, // Signal level
        // Mode-S Short data (8 bytes = 7 + 1 escape)
        0x00, 0xa1, 0x84, 0x1a, 0x1a, 0xc3, 0xb3, 0x1d,
    ];
    let mut reader = &data[..];
    let beast_message = mode.parse_beast_message(&mut reader).unwrap();
    assert_eq!(beast_message.message, [0x0, 0xA1, 0x84, 0x1A, 0xC3, 0xB3, 0x1D]);
    println!("Parsed Beast message: {:#02X}", beast_message.message.as_hex());

    // Test with signal level escaped (0x1a)
    data = vec![
        0x1A, // Message start
        0x32, // Message type: Mode-S Short
        0x08, 0x3e, 0x27, 0xb6, 0xcb, 0x6a, // MLAT timestamp
        0x1a, 0x1a, // Signal level
        // Mode-S Short data (8 bytes = 7 + 1 escape)
        0x00, 0xa1, 0x84, 0x1a, 0x1a, 0xc3, 0xb3, 0x1d,
    ];
    let mut reader = &data[..];
    let beast_message = mode.parse_beast_message(&mut reader).unwrap();
    assert_eq!(beast_message.message, [0x0, 0xA1, 0x84, 0x1A, 0xC3, 0xB3, 0x1D]);
    println!("Parsed Beast message: {:#02X}", beast_message.message.as_hex());

    data = vec![
        0x1A, // Message start
        0x33, // Message type: Mode S long
        0x1A, 0x1A, 0xF9, 0x33, 0xBB, 0xC6, // MLAT timestamp
        0x3E, // Signal level
        // Mode-S Long frame (14 bytes)
        0xC6, 0x8F, 0x1A, 0x1A, 0x9A, 0xDA, 0x58, 0xB9, 0x84, 0x46, 0xE7, 0x03, 0x35, 0x7E, 0x24, 0x1A, 0x1A
    ];
    let mut reader = &data[..];
    let beast_message = mode.parse_beast_message(&mut reader).unwrap();
    assert_eq!(beast_message.message, [0xC6, 0x8F, 0x1A, 0x9A, 0xDA, 0x58, 0xB9, 0x84, 0x46, 0xE7, 0x3, 0x35, 0x7E, 0x24]);
    println!("Parsed Beast message: {:#02X}", beast_message.message.as_hex());

    // ASCII to hex
    //let hex_string = "1a331a1af933bbc63ec68f1a1a9ada58b98446e703357e241a1a";
    //let byte_vector = hex::decode(hex_string).unwrap();
    //println!("{:#02X}", byte_vector.as_hex());
    */

    /*
    //
    //let reader = BufReader::new(io::stdin());
    //let s = "1a331a1af933bbc63ec68f1a1a9ada58b98446e703357e241a1a".as_bytes().to_hex();
    //let s = "1a331a1af933bbc63ec68f1a1a9ada58b98446e703357e241a1a";
    //let reader = BufReader::new(s.as_bytes());
    let reader = BufReader::new(Cursor::new(data2));
    //let reader = BufReader::new("1a331a1af933bbc63ec68f1a1a9ada58b98446e703357e241a1a".as_bytes());
    let mut decoder = Decoder::new(reader);
    decoder.set_strip_escape(true);
    decoder.decode();
    println!("{:?}", decoder.buf);
    println!("timestamp      = {}"  , decoder.timestamp);
    println!("signal level   = {}"  , decoder.signal_level);
    println!("message type   = {:x}", decoder.message.message_type);
    println!("message length = {}"  , decoder.message.message_length);
    //println!("message        = {:?}", decoder.message.message);
    for el in &decoder.message.message {
        println!("{:X}", el);
    }*/

    //////////////////// START CHECKSUM VALIDATION TEST SECTION
    // example 1: expect 0x2218b2
    /*
    let mut msg: Vec<u8> = vec![0x8F, 0x4D, 0x20, 0x23, 0x58, 0x7F, 0x34, 0x5E, 0x35, 0x83, 0x7E, 0x22, 0x18, 0xB2];
    let received_checksum = u32::from(msg[11]) << 16
                          | u32::from(msg[12]) << 8
                          | u32::from(msg[13]);
    println!("Message: {:#02X}; CRC: {:#02X}", msg.as_hex(), received_checksum);
    assert_eq!(received_checksum, modescrc_buffer_crc(&msg[0..11]));
    */

    /*
    // crc is as expected for any kind of data packet
    let mut msg: Vec<u8>;
    msg = vec![0x5E, 0x35, 0x83, 0x7E, 0x22, 0x18, 0xB2];
    println!("crc = {:#02X}", crc(&msg, Some(SHORT_MSG_BITS)));
    // explicitly set bits size
    assert_eq!(crc(&msg, Some(SHORT_MSG_BITS)), 0x2218B2);
    // automatically determine bits size
    assert_eq!(crc(&msg, None), 0x2218B2);
    */

    let mut data: Vec<u8>;
    data = vec![143, 77, 32, 35, 88, 127, 52, 94, 53, 131, 126, 34, 24, 178];
    // explicitly set bits size
    assert_eq!(checksum_compare(&data, Some(LONG_MSG_BITS)), true);
    // automatically determine bits size
    assert_eq!(checksum_compare(&data, None), true);

    // Tests pulled from https://github.com/flightrac/modes-crc/blob/master/test/crc_checker.js
    // test valid checksum for short message
    data = vec![0x5D, 0x4D, 0x20, 0x23, 0x7A, 0x55, 0xA6]; // 40, 0, 16, 36, 220, 121, 76
    assert_eq!(checksum(&data, Some(SHORT_MSG_BITS)), 0x7A55A6);

    // test invalid checksum for short message
    data = vec![0x28, 0x00, 0x10, 0x24, 0xDC, 0x79, 0x4C]; // 40, 0, 16, 36, 220, 121, 76
    assert_eq!(checksum_compare(&data, Some(SHORT_MSG_BITS)), false);

    // test valid checksum for long message
    data = vec![0x8F, 0x4D, 0x20, 0x23, 0x58, 0x7F, 0x34, 0x5E, 0x35, 0x83, 0x7E, 0x22, 0x18, 0xB2]; // 143, 77, 32, 35, 88, 127, 52, 94, 53, 131, 126, 34, 24, 178
    assert_eq!(checksum(&data, Some(LONG_MSG_BITS)), 0x2218B2);

    // test crc is as expected for any kind of data packet
    data = vec![0x28, 0x00, 0x10, 0x24, 0xDC, 0x79, 0x4C];
    assert_eq!(crc(&data, Some(SHORT_MSG_BITS)), 0xDC794C);

    // test passing an invalid frame returns an error
    data  = vec![0x06];
    assert_eq!(checksum(&data, None), 0);

    // test get message bits length from data frame size
    data = vec![0x5D, 0x4D, 0x20, 0x23, 0x7A, 0x55, 0xA6];
    assert_eq!(checksum(&data, None), 0x7A55A6);
    //////////////////// END CHECKSUM VALIDATION TEST SECTION

    // Connect to the server
    let result = TcpStream::connect("127.0.0.1:4000");
    match result {
        Ok(mut stream) => {
            debug!("Successfully connected to the server at 127.0.0.1:4000");
            // Spawn a new thread to handle the connection
            thread::spawn(move || {
                if let Err(e) = handle_connection(&mut stream) {
                    eprintln!("Error handling connection: {}", e);
                }
            });

            // Keep the main thread alive while the connection thread does its work
            // This is a simple way to keep the program running for demonstration purposes
            loop {
                thread::park();
            }
        }
        Err(e) => {
            error!("Failed to connect to the server: {}", e);
        }
    }
}
