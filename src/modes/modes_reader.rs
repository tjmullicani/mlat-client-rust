/*
 * Part of mlat-client-rust (https://github.com/tjmullicani/mlat-client-rust) - an ADS-B multilateration client.
 * Based on mlat-client (https://github.com/mutability/mlat-client)
 * Copyright 2023, Timothy Mullican <timothy.j.mullican@gmail.com>
 * Copyright 2015, Oliver Jowett <oliver@mutability.co.uk>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * References:
 *   https://github.com/firestuff/adsb-tools/blob/master/protocols/beast.md
 *   https://github.com/wiseman/java-mode-s-beast/blob/master/src/main/java/com/lemondronor/modesbeast/BeastMessageParser.java
 *   https://github.com/junzis/sil/blob/master/stream/base.py
 *   https://thepythoncode.com/assistant/code-converter/c/rust/
 */

use std::collections::HashSet;
use std::collections::BTreeMap;
use hex_slice::AsHex;
use log::{error, warn, info, debug, trace};
use std::io::{Read};
use std::hash::{Hash, Hasher};

use adsb_deku::deku::DekuContainerRead;
use adsb_deku::Frame;

// use crate::modes::modes::*;
// use crate::modes::modes_crc::*;
use crate::modes::modes_message::{self, *};
use crate::modes::modes::{self, *};

/* decoder modes */
#[derive(Copy, Eq, PartialEq, Hash, Clone, Debug)]
pub enum DecoderMode {
    Beast,             /* Beast binary, freerunning 48-bit timestamp @ 12MHz */
    Radarcape,         /* Beast binary, 1GHz Radarcape timestamp, UTC synchronized from GPS */
    RadarcapeEmulated, /* Beast binary, 1GHz Radarcape timestamp, not synchronized */
    Avr,               /* AVR, no timestamp */
    Avrmlat,           /* AVR, freerunning 48-bit timestamp @ 12MHz */
    Sbs,               /* Kinetic SBS, freerunning 20MHz 24-bit timestamp, wraps around all the time but we try to widen it */
    None,              /* Not configured */
}

pub const BEAST_ESCAPE: u8               = 0x1A;
// message types
pub const MESSAGE_TYPE_AC: u8            = 0x31; // '1'
pub const MESSAGE_TYPE_MODE_S: u8        = 0x32; // '2'
pub const MESSAGE_TYPE_MODE_L: u8        = 0x33; // '3'
pub const MESSAGE_TYPE_RADARCAPE: u8     = 0x34; // '4'
pub const MESSAGE_TYPE_RADARCAPE_POS: u8 = 0x35; // '5'

// This range of timestamps are treated as synthetic messages (generated by mlat, from UAT, etc)
pub const SYNTHETIC_TIMESTAMP_START: u64 = 0xFF004D4C4154;
pub const SYNTHETIC_TIMESTAMP_END: u64 = SYNTHETIC_TIMESTAMP_START + 10;

/* a ModesReader object */
#[derive(Clone, Debug)]
pub struct ModesReader {
    // decoder characteristics
    decoder_mode: DecoderMode,                      // 
    decoder_mode_string: String,                    // 
    frequency: u64,                                 // timestamp frequency
    epoch: String,                                  // timestamp epoch

    last_timestamp: u64,                            // last seen timestamp
    radarcape_utc_bugfix: bool,                     // 

    // configurable bits
    allow_mode_change: bool,                        // can the decoder change mode based on status messages it receives?
    want_zero_timestamps: bool,                     // should the decoder return messages with zero timestamps?
    want_synthetic_messages: bool,                  // should the decoder return synthetic messages?
    want_invalid_messages: bool,                    // should the decoder return invalid messages?
    want_events: bool,                              // should the decoder return metadata events?

    // filtering
    seen: Vec<i32>,                           // set of addresses seen by the decoder
    default_filter: Vec<bool>,                // DF accept filter for all aircraft
    specific_filter: Vec<Option<HashSet<i32>>>, // DF accept filter for specific aircraft
    modeac_filter: Vec<i32>,                  // Mode A/C accept filter

    // stats
    received_messages: u32,                         // total number of messages decoded
    suppressed_messages: u32,                       // number of messages suppressed by filtering
}

// Constructs a new `ModesReader`.
impl Default for ModesReader {
    fn default() -> ModesReader {
        ModesReader {
            /* minimal init */
            decoder_mode: DecoderMode::None,
            decoder_mode_string: "".to_string(),
            frequency: 0,
            epoch: "".to_string(),
            last_timestamp: 0,
            radarcape_utc_bugfix: false,
            allow_mode_change: true,
            want_zero_timestamps: false,
            want_synthetic_messages: false,
            want_invalid_messages: false,
            want_events: true,
            seen: Vec::new(),
            default_filter: vec![false; 32],
            specific_filter: vec![None; 32],
            modeac_filter: Vec::new(),
            received_messages: 0,
            suppressed_messages: 0,
        }
    }
}
impl ModesReader {
    fn new(
        decoder_mode: DecoderMode,
        decoder_mode_string: String,
        frequency: u64,
        epoch: String,
        last_timestamp: u64, /* last seen timestamp */
        radarcape_utc_bugfix: bool,
        allow_mode_change: bool,
        want_zero_timestamps: bool,
        want_synthetic_messages: bool,
        want_invalid_messages: bool,
        want_events: bool,
        seen: Vec<i32>,
        default_filter: Vec<bool>,
        specific_filter:  Vec<Option<HashSet<i32>>>,
        modeac_filter: Vec<i32>,
        received_messages: u32,
        suppressed_messages: u32,
    ) -> Self {
        ModesReader { 
            decoder_mode,
            decoder_mode_string,
            frequency,
            epoch,
            last_timestamp,
            radarcape_utc_bugfix,
            allow_mode_change,
            want_zero_timestamps,
            want_synthetic_messages,
            want_invalid_messages,
            want_events,
            seen,
            default_filter,
            specific_filter,
            modeac_filter,
            received_messages,
            suppressed_messages,
        }
    }

    pub fn set_decoder_mode(&mut self, newmode: DecoderMode) {
        self.decoder_mode = newmode.clone();
        match newmode {
            DecoderMode::Beast => {
                self.frequency = 12_000_000u64; // assumed
                self.epoch = String::from("");
            },
            DecoderMode::Radarcape => {
                self.frequency = 1_000_000_000u64;
                self.epoch = String::from("utc_midnight");
            },
            DecoderMode::RadarcapeEmulated => {
                self.frequency = 1_000_000_000u64;
                self.epoch = String::from("");
            },
            DecoderMode::Avrmlat => {
                self.frequency = 12_000_000u64; // assumed
                self.epoch = String::from("");
            },
            DecoderMode::Sbs => {
                self.frequency = 20_000_000u64;
                self.epoch = String::from("");
            },
            DecoderMode::Avr | _ => {
                self.frequency = 0;
                self.epoch = String::from("");
            },
        }
    }

   // TODO
   /* feed some data to the reader and does one of:
    *  1) returns a tuple (bytes_consumed, messages, error_pending), or
    *  2) throws an exception
    *
    * If a stream error is seen, but some messages were parsed OK,
    * then an exception is not immediately thrown and the parsed
    * messages are returned with error_pending = true. The caller
    * should call feed again (after consuming the given number of
    * bytes) to get the exception.
    *
    * Internal errors (e.g. out of memory) are thrown immediately.
    */
    /*pub fn feed(&mut self) -> ??? {
        let buffer: PyBuffer;
        let mut rv: Option<PyObject> = None;
        let mut max_messages = 0;
        let kwlist = ["buffer", "max_messages"];

        match self.decoder_mode {
            DecoderMode::None => {
                return Err("decoder mode is None, no decoder type selected");
            }
            DecoderMode::Beast | DecoderMode::Radarcape | DecoderMode::RadarcapeEmulated => {
                rv = Some(feed_beast(self, &buffer, max_messages)?);
            }
            DecoderMode::Avr | DecoderMode::Avrmlat => {
                rv = Some(feed_avr(self, &buffer, max_messages)?);
            }
            DecoderMode::Sbs => {
                rv = Some(feed_sbs(self, &buffer, max_messages)?);
            }
            _ => {
                return Err("decoder somehow got into illegal mode {}");
            }
        }
        rv
    }*/

    // update self->last_timestamp given that we just saw this timestamp
    pub fn timestamp_update(&mut self, timestamp: u64)
    {
        if self.is_synthetic_or_zero_timestamp(timestamp) {
            /* special timestamps, don't use them */
            return;
        }

        if self.last_timestamp == 0 || self.frequency == 0 {
            /* startup cases, just accept whatever */
            self.last_timestamp = timestamp;
            return;
        }

        if self.last_timestamp > timestamp && (self.last_timestamp - timestamp) < 90 * self.frequency {
            /* ignore small moves backwards */
            return;
        }

        if (self.decoder_mode == DecoderMode::Radarcape || self.decoder_mode == DecoderMode::RadarcapeEmulated) &&
            timestamp >= (86340 * 1_000_000_000u64) && self.last_timestamp <= (60 * 1_000_000_000u64) {
            // In radarcape mode, don't allow last_timestamp to roll back to the previous day
            // as we will have already issued an epoch reset
            return;
        }

        self.last_timestamp = timestamp;
    }

    /// Parses a Beast binary message from a reader.
    ///
    /// # Arguments
    ///
    /// * `reader` - A reader that implements the `Read` trait.
    ///
    /// # Returns
    ///
    /// This function returns a `Result` containing a `BeastMessage` if successful,
    /// or an `io::Error` if an error occurs during reading.
    //fn beast(&mut self, buffer: ???, max_messages: i32) -> ??? {
    //pub fn feed_beast(&mut self) -> (i64, (), bool) {
    //pub fn feed_beast(&mut self, mut buffer: Vec<u8>) -> Vec<BeastMessage> {
    pub fn feed_beast(&mut self, mut buffer: Vec<u8>) -> (HashSet<ModesMessage>, bool) {
        let mut timestamp: u64 = 0;
        let mut timestamp_bytes: [u8; 6] = [0; 6];
        let mut signal: u8 = 0;
        let mut m_type: u8 = 0;
        let mut message_tuple: () = ();
        let mut message_count: u32 = 0;
        let mut error_pending: bool = false;

	    let mut messages: HashSet<ModesMessage> = HashSet::new();

        /////////
        let mut messages_mlat: Vec<Vec<u8>> = Vec::new();
        let mut msg: Vec<u8> = Vec::new();
        let mut iter =  buffer.iter().peekable();

        // process the buffer until the last divider <esc> 0x1a
        // then, reset the self.buffer with the remainder
        while let Some(&byte) = iter.next() {
            trace!("byte is {:#02X}", byte);
            match byte {
                BEAST_ESCAPE if iter.peek() == Some(&&BEAST_ESCAPE) => {
                    // If the current and next bytes are BEAST_ESCAPE, append one BEAST_ESCAPE to `msg`
                    msg.push(BEAST_ESCAPE);
                    iter.next(); // Skip the next byte as it's part of the escape sequence
                }
                BEAST_ESCAPE if iter.peek().is_none() => {
                    // Special case where the last byte is BEAST_ESCAPE
                    msg.push(BEAST_ESCAPE);
                }
                BEAST_ESCAPE if iter.peek() == Some(&&MESSAGE_TYPE_AC) => {
                    trace!("new frame");
                    // Start new frame
                    if !msg.is_empty() { messages_mlat.push(msg.clone()); msg.clear(); }
                }
                BEAST_ESCAPE if iter.peek() == Some(&&MESSAGE_TYPE_MODE_S) => {
                    trace!("new frame");
                    // Start new frame
                    if !msg.is_empty() { messages_mlat.push(msg.clone()); msg.clear(); }
                }
                BEAST_ESCAPE if iter.peek() == Some(&&MESSAGE_TYPE_MODE_L) => {
                    trace!("new frame");
                    // Start new frame
                    if !msg.is_empty() { messages_mlat.push(msg.clone()); msg.clear(); }
                }
                _ => {
                    // Otherwise, append the current byte to `msg`
                    msg.push(byte);
                }
            }
        }

        // Save the remander for the next reading cycle, if not empty
        if !msg.is_empty() {
            let mut reminder = Vec::new();
            for (i, &m) in msg.iter().enumerate() {
                if m == BEAST_ESCAPE && i < msg.len() - 1 {
                    // rewind BEAST_ESCAPE, except when it is at the last bit
                    reminder.extend_from_slice(&[m, m]);
                } else {
                    reminder.push(m);
                }
            }
            buffer = std::iter::once(BEAST_ESCAPE).chain(reminder).collect();
        } else {
            buffer.clear();
        }

        // Extract messages
        let mut frames: Vec<BeastMessage> = Vec::new();
        for mm in messages_mlat {
            let mut has_timestamp_signal: bool = true;
            let msgtype = mm[0];

            println!("mm frame is {:#02X}", mm.as_hex());
            let ms: Vec<u8> = match msgtype {
                MESSAGE_TYPE_AC => {
                    if mm.len() != 10 {
                        warn!("invalid message: expected 11 bytes, received {}", mm.len() + 1);
                        error_pending = true;
                        continue;
                    }
                    mm[8..10].to_vec()
                },
                MESSAGE_TYPE_MODE_S => {
                    if mm.len() != 15 {
                        warn!("invalid message: expected 16 bytes, received {}", mm.len() + 1);
                        error_pending = true;
                        continue;
                    }
                    mm[8..15].to_vec()
                },
                MESSAGE_TYPE_MODE_L => {
                    if mm.len() != 22 {
                        warn!("invalid message: expected 23 bytes, received {}", mm.len() + 1);
                        error_pending = true;
                        continue;
                    }
                    mm[8..22].to_vec()
                },
                // FIXME: untested
                MESSAGE_TYPE_RADARCAPE => {
                    if mm.len() != 22 {
                        warn!("invalid message: expected 23 bytes, received {}", mm.len() + 1);
                        error_pending = true;
                        continue;
                    }
                    mm[8..22].to_vec()
                },
                // FIXME: untested
                MESSAGE_TYPE_RADARCAPE_POS => {
                    // if mm.len() != ??? {
                    //     warn!("invalid message: expected ?? bytes, received {}", mm.len() + 1);
                    //     continue;
                    // }
                    has_timestamp_signal = false;
                    mm[8..22].to_vec()
                },
                _ => {
                    debug!("Lost sync with input stream: unexpected message type {:#02X} after {}", msgtype, BEAST_ESCAPE);
                    error_pending = true;
                    continue;
                },
            };

            if ms == [0x00, 0x00] {
                debug!("Empty byte Mode-AC message, skipping");
                continue;
            }

            info!("mm = {:#02X}", mm.as_hex());
            info!("ms = {:#02X}", ms.as_hex());
            let mut timestamp: u64;
            let mut signal: u8;
            if has_timestamp_signal {
                timestamp = u64::from_be_bytes([
                    0, 0, // Pad to 8 bytes
                    mm[1],
                    mm[2],
                    mm[3],
                    mm[4],
                    mm[5],
                    mm[6],
                ]);
                signal = mm[7];
            } else {
                timestamp = 0;
                signal = 0;
            }

            if msgtype == MESSAGE_TYPE_RADARCAPE {
                /* radarcape-style status message, use this to switch our decoder type */
                self.radarcape_utc_bugfix = (mm[2] & 0x80) == 0x80;
    
                if self.allow_mode_change {
                    let new_mode = if mm[0] & 0x10 != 0 {
                        // Radarcape in GPS timestamp mode
                        if (mm[2] & 0x20) == 0x20 {
                            DecoderMode::RadarcapeEmulated
                        } else {
                            DecoderMode::Radarcape
                        }
                    } else {
                        // Radarcape in 12MHz timestamp mode
                        DecoderMode::Beast
                    };
    
                    // Handle mode changes by inserting an event message
                    if new_mode != self.decoder_mode {
                        self.set_decoder_mode(new_mode);
                        if self.want_events {
                            // match make_mode_change_event(self) {
                            //     Some(message) => messages.push(message),
                            //     None => return Err("Failed to create mode change event"),
                            // }
                            // FIXME: define messages (HashSet?)
                            messages.insert(self.make_mode_change_event());
                            message_count += 1;
                        }
                    }

                    if has_timestamp_signal && !self.is_synthetic_or_zero_timestamp(timestamp) {
                        if self.decoder_mode == DecoderMode::Beast {
                            /* 12MHz mode */
            
                            /* check for very out of range value
                             * (dump1090 can hold messages for up to 60 seconds! so be conservative here)
                             * also work around dump1090-mutability issue #47 which can send very stale Mode A/C messages
                             */
                            if self.want_events && msgtype != MESSAGE_TYPE_AC && !self.timestamp_check(timestamp) {
                                messages.insert(self.make_timestamp_jump_event(timestamp));
                                message_count += 1;
                            }

                            /* adjust the timestamps so they always reflect the start of the frame */
                            let mut adjust: u64 = 0;
                            if msgtype == MESSAGE_TYPE_AC {
                                // Mode A/C, timestamp reported at F2 which is 20.3us after F1
                                // this is 243.6 cycles at 12MHz
                                adjust = 244;
                            } else if msgtype == MESSAGE_TYPE_MODE_S {
                                // Mode S short, timestamp reported at end of frame, frame is 8us preamble plus 56us data
                                // this is 768 cycles at 12MHz
                                adjust = 768;
                            } else if msgtype == MESSAGE_TYPE_MODE_L {
                                // Mode S long, timestamp reported halfway through the frame (at bit 56), same offset as Mode S short
                                adjust = 768;
                            }
            
                            // FIXME: could probably optimize
                            if timestamp < adjust {
                                timestamp = 0;
                            } else {
                                timestamp = timestamp - adjust;
                            }
                        } else {
                            // gps mode 
            
                            // adjust timestamp so that it is a contiguous nanoseconds-since-
                            // midnight value, rather than the raw form which skips values once
                            // a second
                            let nanos: u64 = timestamp & 0x00003FFFFFFF;
                            let mut secs: u64 = timestamp >> 30;

            
                            if !self.radarcape_utc_bugfix {
                                /* fix up the timestamp so it is UTC, not 1 second ahead */
                                if secs == 0 {
                                    secs = 86_399;
                                } else {
                                    secs -= 1;
                                }
                            }
            
                            timestamp = nanos + secs * 1_000_000_000;

                            /* adjust the timestamps so they always reflect the start of the frame */
                            let mut adjust: u64 = 0;
                            if msgtype == MESSAGE_TYPE_AC {
                                // Mode A/C, timestamp reported at F2 which is 20.3us after F1
                                adjust = 20_300;
                            } else if msgtype == MESSAGE_TYPE_MODE_S {
                                // Mode S short, timestamp reported at end of frame, frame is 8us preamble plus 56us data
                                adjust = 64_000;
                            } else if msgtype == MESSAGE_TYPE_MODE_L {
                                // Mode S long, timestamp reported at end of frame, frame is 8us preamble plus 112us data
                                adjust = 120_000;
                            }

                            // FIXME: could probably optimize
                            if adjust <= timestamp {
                                timestamp = timestamp - adjust;
                            } else {
                                // wrap it to the previous day
                                timestamp = timestamp + 86_400 * 1_000_000_000 - adjust;
                            }

                            // check for end of day rollover
                            if self.want_events && self.last_timestamp >= (86_340 * 1_000_000_000) && timestamp <= (60 * 1_000_000_000) {
                                messages.insert(self.make_epoch_rollover_event(timestamp));
                                message_count += 1;
                            } else if self.want_events && msgtype != MESSAGE_TYPE_AC && !self.timestamp_check(timestamp) {
                                messages.insert(self.make_timestamp_jump_event(timestamp));
                                message_count += 1;
                            }
                        }

                        if msgtype != MESSAGE_TYPE_AC {
                            self.timestamp_update(timestamp);
                        }
                    }
                }
            }

            if msgtype == MESSAGE_TYPE_RADARCAPE {
                /* radarcape-style status message, emit the status event if wanted */
                if (self.want_events) {
                    messages.insert(self.make_radarcape_status_event(timestamp, ms));
                    message_count += 1;
                }

                // don't try to process this as a Mode S message
                continue;
            }
    
            if msgtype == MESSAGE_TYPE_RADARCAPE_POS {
                /* radarcape-style position message, emit the position event if wanted */
    
                if self.want_events {
                    messages.insert(self.make_radarcape_position_event(ms));
                    message_count += 1;
                }
    
                // don't try to process this as a Mode S message
                continue;
            }

            // it's a Mode A/C or Mode S message, parse it
            let message = modesmessage_from_buffer(timestamp, signal, ms.clone(), ms.len());

            // apply filters, update seen-set
            self.received_messages += 1;
            let wanted = self.filter_message(message.clone());
            if wanted < 0 {
                break;
            } else if wanted > 0 {
                messages.insert(message.clone());
                message_count += 1;
            } else {
                self.suppressed_messages += 1;
            }
        }
    
        let rv = (messages, error_pending);

        rv
        //frames
        /////////

/*
        for message in messages.iter() {
            let message_length = match message_type as u8 {
                MESSAGE_TYPE_AC            => 2,  // mode A/C
                MESSAGE_TYPE_MODE_S        => 7,  // mode S short
                MESSAGE_TYPE_MODE_L        => 14, // mode S long
                MESSAGE_TYPE_RADARCAPE     => 14, // radarcape status message
                MESSAGE_TYPE_RADARCAPE_POS => 21, // radarcape position message, no timestamp/signal bytes
                _                          => {
                    error!("Lost sync with input stream: unexpected message type {:#02X} after {}", message_type as u8, BEAST_ESCAPE);
                    return Err(io::Error::new(io::ErrorKind::InvalidData, "Lost sync with input stream: unexpected message type after BEAST_ESCAPE")); // unsure about offset value
                },
            };
            debug!("feed_beast: message_type = {}", message_type as char);
            debug!("feed_beast: message_length = {}", message_length);
            let has_timestamp_signal = if message_type as char == '5' { false } else { true };
            debug!("feed_beast: has_timestamp_signal = {}", has_timestamp_signal);

            if has_timestamp_signal {
                // Read the timestamp (6 bytes)
                //let mut timestamp_bytes = [0; 6];
                reader.read_exact(&mut timestamp_bytes)?;
                //for byte in timestamp_bytes.iter_mut() {
                //    *byte = read_byte(reader)?;
                //}

                for i in 0..6 {
                    trace!("feed_beast: timestamp_bytes[{}] = {:#02X}", i, timestamp_bytes[i]);
               }

                timestamp = u64::from_be_bytes([
                    0, 0, // Pad to 8 bytes
                    timestamp_bytes[0],
                    timestamp_bytes[1],
                    timestamp_bytes[2],
                    timestamp_bytes[3],
                    timestamp_bytes[4],
                    timestamp_bytes[5],
                ]);
                debug!("feed_beast: timestamp = {}", timestamp);

                // Read the signal level (1 byte)
                signal = read_byte(&mut reader)?;
                debug!("feed_beast: signal = {:#02X}", signal);
            }

            // Read the message payload (variable length)
            //let mut message = read_bytes(&mut reader, message_length);
            let mut message = Vec::new();
            // Attempt to read bytes into the message buffer
            match read_bytes(&mut reader, message_length) {
                Ok(bytes) => {
                    message = bytes;
                },
                Err(err) => {
                    warn!("Error reading message: {}", err);
                    continue;
                }
            };
            
            debug!("feed_beast: message  = {:#02X}", message.as_hex());
            //trace!("feed_beast: checksum = {:#02X}", checksum(&message, None));
            debug!("feed_beast: message checksum valid = {}", checksum_compare(&message, None));
            //assert_eq!(checksum_compare(&message, None), true);

            if checksum_compare(&message, None) {
                self.received_messages += 1;
            } else {
                warn!("feed_beast: Checksum invalid");
                continue;
            }

/////////////////////////////////////////////////////////////////////
            // do some filtering

            if m_type as char == '4' {
                debug!("feed_beast: m_type == 4");
                /* radarcape-style status message, use this to switch our decoder type */

                self.radarcape_utc_bugfix = (message[2] & 0x80) == 0x80; //verify message[2] == data[2]

                if self.allow_mode_change {
                    trace!("feed_beast: self.allow_mode_change");
                    let newmode: DecoderMode;
                    if message[0] & 0x10 != 0 { // verify message[0] == data[0]
                        /* radarcape in GPS timestamp mode */
                        if (message[2] & 0x20) == 0x20 { // verify message[2] == data[2]
                            trace!("feed_beast: change mode to RadarcapeEmulated");
                            newmode = DecoderMode::RadarcapeEmulated;
                        } else {
                            trace!("feed_beast: change mode to Radarcape");
                            newmode = DecoderMode::Radarcape;
                        }
                    } else {
                        /* radarcape in 12MHz timestamp mode */
                        trace!("feed_beast: change mode to Beast");
                        newmode = DecoderMode::Beast;
                    }

                    /* handle mode changes by inserting an event message */
                    if newmode != self.decoder_mode {
                        trace!("feed_beast: newmode != self.decoder_mode");
                        trace!("feed_beast: set_decoder_mode({:?})", newmode);
                        self.set_decoder_mode(newmode);
                        /*if self.want_events {
                            //if ! (messages[message_count++] = make_mode_change_event(self))
                            // TODO
                            if !messages[message_count] = self.make_mode_change_event() {
                                debug!("feed_beast: message_count += 1");
                                message_count += 1;
                            }
                            // goto out;
                            // TODO
                            let message_length = 0;
                            let timestamp = 0;
                            let signal_level = 0;
                            let message: Vec<u8> = Vec::new();
                            Ok(BeastMessage {
                                message_length,
                                timestamp,
                                signal_level,
                                message,
                            })
                        }*/
                    }
                }
            }

            /*
            if has_timestamp_signal && !self.is_synthetic_or_zero_timestamp(timestamp) {
                if self.decoder_mode == DecoderMode::Beast {
                    /* 12MHz mode */

                    /* check for very out of range value
                     * (dump1090 can hold messages for up to 60 seconds! so be conservative here)
                     * also work around dump1090-mutability issue #47 which can send very stale Mode A/C messages
                     */
                    if self.want_events && m_type as char != '1' && !self.timestamp_check(timestamp) {
                        if !messages[message_count] = self.make_timestamp_jump_event(timestamp) {
                            message_count += 1;
                            // goto out;
                        }
                    }

                    /* adjust the timestamps so they always reflect the start of the frame */
                    let adjust: u64;
                    if m_type as char == '1' {
                        // Mode A/C, timestamp reported at F2 which is 20.3us after F1
                        // this is 243.6 cycles at 12MHz
                        adjust = 244;
                    } else if m_type as char == '2' {
                        // Mode S short, timestamp reported at end of frame, frame is 8us preamble plus 56us data
                        // this is 768 cycles at 12MHz
                        adjust = 768;
                    } else if m_type as char == '3' {
                        // Mode S long, timestamp reported halfway through the frame (at bit 56), same offset as Mode S short
                        adjust = 768;
                    } else {
                        // anything else we assume is already correct
                        adjust = 0;
                    }

                    if timestamp < adjust {
                        timestamp = 0;
                    } else {
                        timestamp = timestamp - adjust;
                    }
                } else {
                    /* gps mode */

                    /* adjust timestamp so that it is a contiguous nanoseconds-since-
                     * midnight value, rather than the raw form which skips values once
                     * a second
                     */
                    let nanos: u64 = timestamp & 0x00003FFFFFFF;
                    let secs: u64 = timestamp >> 30;

                    if !self.radarcape_utc_bugfix {
                        /* fix up the timestamp so it is UTC, not 1 second ahead */
                        if secs == 0 {
                            secs = 86399;
                        } else {
                            --secs;
                        }
                    }

                    timestamp = nanos + secs * 1000000000;

                    /* adjust the timestamps so they always reflect the start of the frame */
                    let adjust: u64;
                    if m_type as char == '1' {
                        // Mode A/C, timestamp reported at F2 which is 20.3us after F1
                        adjust = 20300;
                    } else if m_type as char == '2' {
                        // Mode S short, timestamp reported at end of frame, frame is 8us preamble plus 56us data
                        adjust = 64000;
                    } else if m_type as char == '3' {
                        // Mode S long, timestamp reported at end of frame, frame is 8us preamble plus 112us data
                        adjust = 120000;
                    } else {
                        // anything else we assume is already correct
                        adjust = 0;
                    }

                    if adjust <= timestamp {
                        timestamp = timestamp - adjust;
                    } else {
                        /* wrap it to the previous day */
                        timestamp = timestamp + 86400 * 1_000_000_000 - adjust;
                    }

                    /* check for end of day rollover */
                    if self.want_events && self.last_timestamp >= 86340 * 1_000_000_000 && timestamp <= 60 * 1_000_000_000 {
                        if !messages[message_count] = make_epoch_rollover_event(timestamp) {
                            message_count += 1;
                            // goto out;
                        }
                    } else if self.want_events && m_type as char != '1' && !timestamp_check(timestamp) {
                        if !messages[message_count] = make_epoch_jump_event(timestamp) {
                            message_count += 1;
                            // goto out;
                        }
                    }
                }

                if m_type as char != '1' {
                    self.timestamp_update(timestamp);
                }
            }
            */

            /*
            if m_type as char == '4' {
                /* radarcape-style status message, emit the status event if wanted */
                if self.want_events {
                    if !messages[message_count] = self.make_radarcape_status_event(timestamp, data) {
                        message_count += 1;
                        // goto out;
                    }
                }

                /* don't try to process this as a Mode S message */
                p = m;
                continue;
            }

            if m_type as char == '5' {
                /* radarcape-style position message, emit the position event if wanted */

                if self.want_events {
                    if !messages[message_count] = self.make_radarcape_position_event(data) {
                        message_count += 1;
                        // goto out;
                    }
                }

                /* don't try to process this as a Mode S message */
                p = m;
                continue;
            }

            /* it's a Mode A/C or Mode S message, parse it */
            if !(message = modesmessage_from_buffer(timestamp, signal, data, message_len)) {
                // goto out;
            }

            /* apply filters, update seen-set */
            self.received_messages += 1;
            wanted = self.filter_message(message);
            if wanted < 0 {
                // goto out;
            } else if wanted {
                messages[message_count] = message;
                message_count += 1;
            } else {
                self.suppressed_messages += 1;
            }

            p = m;*/
        }

        //if !(message_tuple = PyTuple_New(message_count)) {
        // goto out;
        //}

    //while message_count >= 0 {
        //PyTuple_SET_ITEM(message_tuple, message_count, messages[message_count]); /* steals ref */
        //message_tuple.set_item(message_count, messages[message_count]);
    //    message_count -= 1;
    //}

    //rv = Py_BuildValue("(l,N,N)", (long) (p - buffer_start), message_tuple, PyBool_FromLong(error_pending));
    //let rv = ((p as usize - buffer_start as usize) as i64, message_tuple, error_pending);

    //return rv;
/////////////////////////////////////////////////////////////////////

        let message_length = 0;
        let timestamp = 0;
        let signal_level = 0;
        let message: Vec<u8> = Vec::new();
        Ok(BeastMessage {
            message_length,
            timestamp,
            signal_level,
            message,
        })
*/
    }

    // inspect a message, update the seen set
    // return 1 if we should pass this message on to the caller
    // return 0 if we should drop it
    // return -1 on internal error (exception has been raised)
    pub fn filter_message(&mut self, message: ModesMessage) -> i32 {
        if message.df == DF_MODEAC && self.modeac_filter.contains(&message.address) {
            return 1;
        } else {
            return 0;
        }
    
        if !message.valid {
            return self.want_invalid_messages as i32; // don't process further, contents are dubious
        }
    
        if message.df == 11 || message.df == 17 || message.df == 18 {
            // note that we saw this aircraft, even if the message is filtered.
            // only do this for CRC-checked messages as we get a lot of noise
            // otherwise.
            self.seen.push(message.address);
        }

        if message.timestamp == 0 && !self.want_zero_timestamps {
            return 0;
        }

        if self.is_synthetic_timestamp(message.timestamp) && !self.want_synthetic_messages {
            return 0;
        }

        // if self.default_filter.is_none() &&self.specific_filter.is_none() {
        //     // no filters installed, match everything
        //     return 1;
        // }

        // check per-type filters
        // FIXME: test code
        let mut rv: i8;
        match self.default_filter.get(message.df as usize) {
            Some(entry) => {
                if *entry { return 1; } else { return 0; }
            },
            None => {
                return -1;
            },
        }

        // FIXME: test code
        match self.specific_filter.get(message.df as usize) {
            Some(Some(entry)) => {
                if entry.contains(&message.address) {
                    return *entry.get(&message.address).unwrap();
                } else {
                    return 0;
                }
            },
            Some(None) => {
                return -1;
            },
            None => {
                return -1;
            }
        }

        0
    }

    pub fn timestamp_check(&mut self, timestamp: u64) -> bool {
        if self.is_synthetic_or_zero_timestamp(timestamp) {
            return true;
        }

        if self.last_timestamp == 0 {
            return true;
        }

        if self.frequency == 0 {
            return true;
        }

        if self.last_timestamp > timestamp && (self.last_timestamp - timestamp) > 90 * self.frequency {
            return false;
        }

        if self.last_timestamp < timestamp && (timestamp - self.last_timestamp) > 90 * self.frequency {
            return false;
        }

        true
    }

    /*
    pub fn timestamp_update(&mut self, timestamp: u64) {
        if self.is_synthetic_or_zero_timestamp(timestamp) {
            // special timestamps, don't use them
            return;
        }

        if self.last_timestamp == 0 || self.frequency == 0 {
            self.last_timestamp = timestamp;
            return ;
        }

        if self.last_timestamp > timestamp && (self.last_timestamp - timestamp) < 90 * self.frequency {
            // ignore small moves backwards
            return;
        }

        if (self.decoder_mode == DecoderMode::Radarcape || self.decoder_mode == DecoderMode::RadarcapeEmulated) &&
            timestamp >= 86340 * 1000000000 && self.last_timestamp <= 60 * 1000000000 {
                // in radarcape mode, don't allow last_timestamp to roll back to the previous day
                // as we will have already issued an epoch reset
                return;
        }

        self.last_timestamp = timestamp;
    }
    
    pub fn make_radarcape_position_event(&mut self, data: u8) {
        let eventdata = self.radarcape_position_to_dict(data);

        return modesmessage_new_eventmessage(DF_EVENT_RADARCAPE_POSITION, 0, eventdata);
    }*/

    pub fn make_radarcape_position_event(&mut self, data: Vec<u8>) -> ModesMessage {
        let eventdata = self.radarcape_position_to_dict(data).unwrap();

        return modesmessage_new_eventmessage(DF_EVENT_RADARCAPE_POSITION, 0, eventdata);
    }

    pub fn is_synthetic_or_zero_timestamp(&mut self, timestamp: u64) -> bool {
        return timestamp == 0 || self.is_synthetic_timestamp(timestamp);
    }

    pub fn is_synthetic_timestamp(&mut self, timestamp: u64) -> bool {
        return timestamp >= SYNTHETIC_TIMESTAMP_START && timestamp <= SYNTHETIC_TIMESTAMP_END;
    }

    pub fn radarcape_position_to_dict(&mut self, data: Vec<u8>) -> Option<BTreeMap<String, EventData>> {
        let lat = f32::from_le_bytes(data[4..8].try_into().unwrap());
        let lon = f32::from_le_bytes(data[8..12].try_into().unwrap());
        let alt = f32::from_le_bytes(data[12..16].try_into().unwrap());

        // Check for errors (assuming -1.0 is the error value)
        if lat == -1.0 || lon == -1.0 || alt == -1.0 {
            // In Rust, we return None to indicate an error instead of NULL
            return None;
        }

        let mut map = BTreeMap::new();
        map.insert("lat".to_string(), EventData::Float(lat));
        map.insert("lon".to_string(), EventData::Float(lon));
        map.insert("alt".to_string(), EventData::Float(alt));

        Some(map)
    }

    /* inspect a message, update the seen set
    * return 1 if we should pass this message on to the caller
    * return 0 if we should drop it
    * return -1 on internal error (exception has been raised)
    */
    /*
    pub fn filter_message(&mut self, message: &ModesMessage) -> i32 {
        if message.df == DF_MODEAC {
            if let Some(modeac_filter) = &self.modeac_filter {
                return modeac_filter.contains(&message.address) as i32;
            }
            return 1;
        }

        if !message.valid {
            return self.want_invalid_messages as i32;
        }

        if let Some(seen) = &self.seen {
            if [11, 17, 18].contains(&message.df) && seen.insert(message.address.clone()) {
                return -1;
            }
        }

        if message.timestamp == 0 && !self.want_zero_timestamps {
            return 0;
        }

        if self.is_synthetic_timestamp(message.timestamp) && !self.want_mlat_messages {
            return 0;
        }

        if self.default_filter.is_none() && self.specific_filter.is_none() {
            return 1;
        }

        if let Some(entry) = self.default_filter.as_ref().and_then(|filter| filter.get(&message.df)) {
            return entry.is_true() as i32;
        }

        if let Some(entry) = self.specific_filter.as_ref().and_then(|filter| filter.get(&message.df)) {
            return entry.map_or(0, |entry| entry.contains(&message.address) as i32);
        }

        0
    }
    */

    // create an event message for a timestamp jump
    pub fn make_timestamp_jump_event(&mut self, timestamp: u64) -> ModesMessage {
        let mut eventdata = BTreeMap::new();
        eventdata.insert("last-timestamp".to_string(), EventData::Frequency(self.last_timestamp));

        return modesmessage_new_eventmessage(DF_EVENT_TIMESTAMP_JUMP, timestamp, eventdata);
    }

    // static PyObject *make_mode_change_event(modesreader *self)
    // {
    //     PyObject *eventdata = Py_BuildValue("{s:N,s:K,s:s}",
    //                                         "mode", modesreader_getmode(self, NULL),
    //                                         "frequency", self->frequency,
    //                                         "epoch", self->epoch);
    //     if (eventdata == NULL)
    //         return NULL;
    //     return modesmessage_new_eventmessage(DF_EVENT_MODE_CHANGE, 0, eventdata);
    // }

    // create an event message for an epoch rollover (e.g. GPS end of day)
    pub fn make_epoch_rollover_event(&mut self, timestamp: u64) -> ModesMessage {
        let eventdata = BTreeMap::new();

        return modesmessage_new_eventmessage(DF_EVENT_EPOCH_ROLLOVER, timestamp, eventdata);
    }

    // create an event message for a decoder mode change. the new mode should already be set.
    pub fn make_mode_change_event(&mut self) -> ModesMessage {
        let mut eventdata = BTreeMap::new();
        eventdata.insert("mode".to_string(), EventData::Mode(self.decoder_mode.clone()));
        eventdata.insert("frequency".to_string(), EventData::Frequency(self.frequency));
        eventdata.insert("epoch".to_string(), EventData::Epoch(self.epoch.clone()));

       return modesmessage_new_eventmessage(DF_EVENT_MODE_CHANGE, 0, eventdata);
    }

    // create an event message for a radarcape status report
    pub fn make_radarcape_status_event(&mut self, timestamp: u64, data: Vec<u8>) -> ModesMessage {
        let mut eventdata = radarcape_status_to_dict(data);

        return modesmessage_new_eventmessage(DF_EVENT_RADARCAPE_STATUS, timestamp, eventdata);
    }
}

// turn a radarcape DIP switch setting byte into a Python list of settings strings
pub fn radarcape_settings_to_list(settings: u8) -> Vec<String> {
    vec![
        if settings & 0x01 != 0 { "beast".to_string() } else if settings & 0x04 != 0 { "avrmlat".to_string() } else { "avr".to_string() },
        if settings & 0x02 != 0 { "filtered_frames".to_string() } else { "all_frames".to_string() },
        if settings & 0x08 != 0 { "no_crc".to_string() } else { "check_crc".to_string() },
        if settings & 0x10 != 0 { "gps_timestamps".to_string() } else { "legacy_timestamps".to_string() },
        if settings & 0x20 != 0 { "rtscts".to_string() } else { "no_rtscts".to_string() },
        if settings & 0x40 != 0 { "no_fec".to_string() } else { "fec".to_string() },
        if settings & 0x80 != 0 { "modeac".to_string() } else { "no_modeac".to_string() },
    ]
}

// turn a radarcape GPS status byte into a Python dict
pub fn radarcape_gpsstatus_to_dict(status: u8) -> BTreeMap<String, bool> {
    let mut gps_status = BTreeMap::new();

    if status & 0x80 == 0 {
        gps_status.insert("utc_bugfix".to_string(), false);
        gps_status.insert("timestamp_ok".to_string(), true);
    } else {
        gps_status.insert("utc_bugfix".to_string(), true);
        gps_status.insert("timestamp_ok".to_string(), status & 0x20 == 0);
        gps_status.insert("sync_ok".to_string(), status & 0x10 != 0);
        gps_status.insert("utc_offset_ok".to_string(), status & 0x08 != 0);
        gps_status.insert("sats_ok".to_string(), status & 0x04 != 0);
        gps_status.insert("tracking_ok".to_string(), status & 0x02 != 0);
        gps_status.insert("antenna_ok".to_string(), status & 0x01 != 0);
    }

    gps_status
}

// turn a radarcape 0x34 status message into a Python dict
pub fn radarcape_status_to_dict(message: Vec<u8>) -> BTreeMap<String, EventData> {
    let mut status_dict = BTreeMap::new();

    // Convert the first byte to a list and add it to the dictionary
    status_dict.insert("settings".to_string(), EventData::SettingsList(radarcape_settings_to_list(message[0])));

    // Convert the second byte to an i8 and add it to the dictionary
    let timestamp_pps_delta: i8 = message[1] as i8;
    status_dict.insert("timestamp_pps_delta".to_string(), EventData::Integer(timestamp_pps_delta as i32));

    // Convert the third byte to a dictionary and add it to the dictionary
    status_dict.insert("gps_status".to_string(), EventData::GpsStatus(radarcape_gpsstatus_to_dict(message[2])));

    status_dict
}

#[derive(Debug, Clone)]
pub enum EventData {
    Mode(DecoderMode),
    Frequency(u64),
    Epoch(String),
    SettingsList(Vec<String>),
    Integer(i32),
    Float(f32),
    GpsStatus(BTreeMap<String, bool>),
}

impl PartialEq for EventData {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (EventData::Mode(a), EventData::Mode(b)) => a == b,
            (EventData::Frequency(a), EventData::Frequency(b)) => a == b,
            (EventData::Epoch(a), EventData::Epoch(b)) => a == b,
            (EventData::SettingsList(a), EventData::SettingsList(b)) => a == b,
            (EventData::Integer(a), EventData::Integer(b)) => a == b,
            (EventData::Float(a), EventData::Float(b)) => (a - b).abs() < std::f32::EPSILON,
            (EventData::GpsStatus(a), EventData::GpsStatus(b)) => a == b,
            _ => false,
        }
    }
}

impl Eq for EventData {}

impl Hash for EventData {
    fn hash<H: Hasher>(&self, state: &mut H) {
        match self {
            EventData::Mode(mode) => {
                state.write_u8(*mode as u8);
            }
            EventData::Frequency(freq) => {
                state.write_u64(*freq);
            }
            EventData::Epoch(epoch) => {
                epoch.hash(state);
            }
            EventData::SettingsList(list) => {
                for item in list {
                    item.hash(state);
                }
            }
            EventData::Integer(value) => {
                state.write_i32(*value);
            }
            EventData::Float(value) => {
                state.write_u32(value.to_bits());
            }
            EventData::GpsStatus(status) => {
                for (key, value) in status {
                    key.hash(state);
                    value.hash(state);
                }
            }
        }
    }
}

/// Represents a Mode-S Beast binary message.
#[derive(Debug)]
pub struct BeastMessage {
    pub message_type: u8,
    pub message_length: usize,
    pub timestamp: u64,
    pub signal_level: u8,
    pub message: Vec<u8>,
    pub message_parsed: Option<adsb_deku::Frame>,
}

impl BeastMessage {
    fn to_string(&self) -> String {
        // FIXME: add message, message_parsed
        format!("Timestamp: {},\n Signal: {}", self.timestamp, self.signal_level)
    }
}

// Handles a single TCP connection
//
// # Arguments
// * `stream` - The TCP stream to read data from
/*
fn handle_connection(stream: &mut TcpStream) -> io::Result<()> {
    // Wrap the stream in a BufReader, so we can use the BufRead methods
    //let mut reader = BufReader::with_capacity(10000, stream);
    let mut reader = BufReader::new(stream);

    loop {
        // Read current data in the TcpStream
        let received: Vec<u8> = reader.fill_buf()?.to_vec();

        // If no data is received, the connection might have been closed
        if received.is_empty() {
            println!("No data received. Connection might be closed.");
            break;
        }

        // Mark the bytes read as consumed so the buffer will not return them in a subsequent read
        reader.consume(received.len());

        let frame_locations = find_frame_starts(&received);
        trace!("handle_connection: frame_locations.len() = {}", frame_locations.len());
        let beast_messages: HashSet<Vec<u8>> = frame_locations
            .iter()
            .map(|(start_index, end_index)| received[*start_index..*end_index].to_vec())
            .collect();

        let mut mode = ModesReader::default();
        mode.set_decoder_mode(DecoderMode::Beast);
        mode.buffer = beast_messages.clone();
        match mode.feed_beast() {
            Ok(o) => {},
            Err(e) => error!("handle_connection: {}", e),
        }
        warn!("Extracted {} valid messages against CRC", mode.received_messages);
    }
    

    Ok(())
}
*/

/*
fn main() {
    env_logger::init();

    let mut mode = ModesReader::default();
    mode.set_decoder_mode(DecoderMode::Beast);

    // In this version, the parse_beast_format function takes a reference to a HashSet<Vec<u8>> where each Vec<u8> represents a Beast format message. The function iterates over the HashSet, attempting to parse each Vec<u8> as a message, and collects successfully parsed messages into a Vec<AdsbMessage>. The main function demonstrates how to use this function with a dummy HashSet containing two Beast messages.
    // Example usage of the `parse_beast_format` function
    // Create a dummy HashSet with Beast format message bytes
    //let mut beast_messages = HashSet::new();
    //beast_messages.insert(message);

    // Parse the Beast format messages
    // let parsed_messages = beast(&beast_messages);

    //for adsb_msg in beast_messages {
        /*println!("Parsed ADS-B Message:");
        println!("Message Type: {}", adsb_msg.msg_type);
        println!("ICAO Address: {:06X}", adsb_msg.icao_address);
        println!("Payload: {:?}", adsb_msg.payload);*/
        // Parse the Beast format message
        //let m: Vec<(String, SystemTime)> = beast(&adsb_msg);
        //println!("Parsed ADS-B Message:");
        //println!("{:?}", m);
        //println!("MSG Type: {}", m.msg_type);
        //println!("Timestamp: {}", m.timestamp);
        //println!("Signal Level: {:04X}", m.signal_level);
        //println!("Mode-S Data: {:?}", m.mode_s_data);
        //for bit in m.mode_s_data {
        //    println!("{:x}", bit);
        //}
    //}

    // Create a new BeastStream instance
    /*let host = String::from("example.com");
    let port = 1234;
    let df_filter = Some(vec![0x31, 0x32, 0x33]);  // Example filter
    let buff_size = 1024;
    let output_dir = Some(String::from("/path/to/output"));
    let mut beast_stream = BeastStream::new(host, port, df_filter, buff_size, output_dir);

    // Simulate receiving a buffer of data
    let mut buffer: Vec<u8> = vec![0x1A, 0x32, 0x08, 0x3E, 0x27, 0xB6, 0xCB, 0x6A, 0x1A, 0x1A, 0x00, 0xA1, 0x84, 0x1A, 0x1A, 0xC3, 0xB3, 0x1D];
    beast_stream.base_stream.buffer = buffer;

    // Process the buffer and extract messages
    let messages = beast_stream.read_message_in_buffer();

    // Print the extracted messages and their timestamps
    for (msg, ts) in messages {
        println!("Received message: {:?}, Timestamp: {:?}", msg, ts);
    }

    // Example usage: parse a Beast message from a byte slice.
    // This byte slice should be replaced with actual data from a Beast receiver.
    let data = vec![
        0x1A, // Message start
        0x33, // Message type: Mode-S Long
        0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, // MLAT Timestamp
        0xFF, // Signal level
        // Mode-S Long message payload (14 bytes)
        0x8D, 0x48, 0x40, 0xD6, 0x20, 0x2C, 0x4B, 0x8E, 0x57, 0x60, 0x98, 0x3B, 0x56, 0x2D,
    ];
    let mut reader = &data[..];
    let beast_message = parse_beast_message(&mut reader).unwrap();
    println!("Parsed Beast message: {:?}", beast_message);
    */

    //////////////////// BEAST VALIDATION SECTION
    /*
    let mut data: Vec<u8>;
    data = vec![
        0x1A, // Message start
        0x32, // Message type: Mode-S Short
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, // MLAT timestamp
        0xFF, // Signal level
        // Mode-S Short data (7 bytes)
        0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97
    ];
    beast_messages.insert(data);
    mode.buffer = beast_messages.clone();
    mode.feed_beast();
    */

    //assert_eq!(mode.message, [0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97]);
    //assert_eq!(mode.signal, 0xFF); //TODO
    //assert_eq!(mode.parity, true); //TODO

    // Validate the checksum of the frame
    //let is_valid = validate_checksum_short(&[0x8D, 0x48, 0x50, 0x15, 0x22, 0x37, 0x56]); // Mode-S Short message
    //let is_valid = validate_checksum_long(&[0x8D, 0x48, 0x40, 0xD6, 0x20, 0x2C, 0xC3, 0x71, 0xC3, 0x2C, 0xE0, 0x57, 0x60, 0x98]); // Mode-S Long message
    //let mut msg: [u32; 4] = [
    //    0x8D4840D6,
    //    0x202CC371,
    //    0xC32CE057,
    //    0x6098, // Note: This is the last 16 bits of the message, the last 8 bits are assumed to be 0
    //];
    //let mut msg: Vec<u8> = vec![
        //0x8D, 0x48, 0x40, 0xD6,
        //0x20, 0x2C, 0xC3, 0x71,
        //0xC3, 0x2C, 0xE0, 0x57,
        //0x60, 0x98 // Note: This is the last 16 bits of the message, the last 8 bits are assumed to be 0
    //];
    // Calculate the checksum
    //calculate_checksum(&mut msg);
    // Check if the message is corrupted
    //let corrupted = is_msg_corrupted(&msg);
    // Output the result
    //println!("The message is {}", if corrupted { "corrupted" } else { "not corrupted" });

    //data = vec![
    //
    //];
    //beast_messages.insert(data);
    //mode.buffer = beast_messages.clone();
    //mode.feed_beast();
    //assert_eq!(mode.message, [0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27]);
    //assert_eq!(mode.signal, 0x

    /*
    // Test escape discard error
    let mut data: Vec<u8>;
    data = vec![
        0x1a, // Message start
        0x31, // Message type: AC
        0x1a, 0x1a, 0x1a // MLAT timestamp
    ];
    //let mut reader = &data[..];
    //let beast_message = mode.parse_beast_message(&mut reader);
    //assert_eq!(beast_message.unwrap_err().to_string(), "failed to fill whole buffer");

    // Test read unread error
    data = vec![
        0x1a, // Message start
        0x31, // Message type: AC
        0x1a, // MLAT timestamp
    ];
    let mut reader = &data[..];
    let beast_message = mode.parse_beast_message(&mut reader);
    assert_eq!(beast_message.unwrap_err().to_string(), "failed to fill whole buffer");

    // Test after seek discard error
    data = vec![
        0xff, 0xff, 0xff, 0xff, 0x1a, 0x31, 0x1a, 0x31
    ];
    let mut reader = &data[..];
    let beast_message = mode.parse_beast_message(&mut reader);
    assert_eq!(beast_message.unwrap_err().to_string(), "Lost sync with input stream: expected a 0x1A marker");

    // Test after seek peek error
    data = vec![
        0xff, 0xff, 0xff, 0xff, 0x1a, 0x31
    ];
    let mut reader = &data[..];
    let beast_message = mode.parse_beast_message(&mut reader);
    assert_eq!(beast_message.unwrap_err().to_string(), "Lost sync with input stream: expected a 0x1A marker");

    // Test seek peek error
    data = vec![
        0xff, 0xff, 0xff
    ];
    let mut reader = &data[..];
    let beast_message = mode.parse_beast_message(&mut reader);
    assert_eq!(beast_message.unwrap_err().to_string(), "Lost sync with input stream: expected a 0x1A marker");

    // Test with signal level NOT escaped
    data = vec![
        0x1A, // Message start
       0x32, // Message type: Mode-S Short
        0x08, 0x3e, 0x27, 0xb6, 0xcb, 0x6a, // MLAT timestamp
        0x1b, // Signal level
        // Mode-S Short data (8 bytes = 7 + 1 escape)
        0x00, 0xa1, 0x84, 0x1a, 0x1a, 0xc3, 0xb3, 0x1d,
    ];
    let mut reader = &data[..];
    let beast_message = mode.parse_beast_message(&mut reader).unwrap();
    assert_eq!(beast_message.message, [0x0, 0xA1, 0x84, 0x1A, 0xC3, 0xB3, 0x1D]);
    println!("Parsed Beast message: {:#02X}", beast_message.message.as_hex());

    // Test with signal level escaped (0x1a)
    data = vec![
        0x1A, // Message start
        0x32, // Message type: Mode-S Short
        0x08, 0x3e, 0x27, 0xb6, 0xcb, 0x6a, // MLAT timestamp
        0x1a, 0x1a, // Signal level
        // Mode-S Short data (8 bytes = 7 + 1 escape)
        0x00, 0xa1, 0x84, 0x1a, 0x1a, 0xc3, 0xb3, 0x1d,
    ];
    let mut reader = &data[..];
    let beast_message = mode.parse_beast_message(&mut reader).unwrap();
    assert_eq!(beast_message.message, [0x0, 0xA1, 0x84, 0x1A, 0xC3, 0xB3, 0x1D]);
    println!("Parsed Beast message: {:#02X}", beast_message.message.as_hex());

    data = vec![
        0x1A, // Message start
        0x33, // Message type: Mode S long
        0x1A, 0x1A, 0xF9, 0x33, 0xBB, 0xC6, // MLAT timestamp
        0x3E, // Signal level
        // Mode-S Long frame (14 bytes)
        0xC6, 0x8F, 0x1A, 0x1A, 0x9A, 0xDA, 0x58, 0xB9, 0x84, 0x46, 0xE7, 0x03, 0x35, 0x7E, 0x24, 0x1A, 0x1A
    ];
    let mut reader = &data[..];
    let beast_message = mode.parse_beast_message(&mut reader).unwrap();
    assert_eq!(beast_message.message, [0xC6, 0x8F, 0x1A, 0x9A, 0xDA, 0x58, 0xB9, 0x84, 0x46, 0xE7, 0x3, 0x35, 0x7E, 0x24]);
    println!("Parsed Beast message: {:#02X}", beast_message.message.as_hex());

    // ASCII to hex
    //let hex_string = "1a331a1af933bbc63ec68f1a1a9ada58b98446e703357e241a1a";
    //let byte_vector = hex::decode(hex_string).unwrap();
    //println!("{:#02X}", byte_vector.as_hex());
    */

    /*
    //
    //let reader = BufReader::new(io::stdin());
    //let s = "1a331a1af933bbc63ec68f1a1a9ada58b98446e703357e241a1a".as_bytes().to_hex();
    //let s = "1a331a1af933bbc63ec68f1a1a9ada58b98446e703357e241a1a";
    //let reader = BufReader::new(s.as_bytes());
    let reader = BufReader::new(Cursor::new(data2));
    //let reader = BufReader::new("1a331a1af933bbc63ec68f1a1a9ada58b98446e703357e241a1a".as_bytes());
    let mut decoder = Decoder::new(reader);
    decoder.set_strip_escape(true);
    decoder.decode();
    println!("{:?}", decoder.buf);
    println!("timestamp      = {}"  , decoder.timestamp);
    println!("signal level   = {}"  , decoder.signal_level);
    println!("message type   = {:x}", decoder.message.message_type);
    println!("message length = {}"  , decoder.message.message_length);
    //println!("message        = {:?}", decoder.message.message);
    for el in &decoder.message.message {
        println!("{:X}", el);
    }*/

    //////////////////// START CHECKSUM VALIDATION TEST SECTION
    // example 1: expect 0x2218b2
    /*
    let mut msg: Vec<u8> = vec![0x8F, 0x4D, 0x20, 0x23, 0x58, 0x7F, 0x34, 0x5E, 0x35, 0x83, 0x7E, 0x22, 0x18, 0xB2];
    let received_checksum = u32::from(msg[11]) << 16
                          | u32::from(msg[12]) << 8
                          | u32::from(msg[13]);
    println!("Message: {:#02X}; CRC: {:#02X}", msg.as_hex(), received_checksum);
    assert_eq!(received_checksum, modescrc_buffer_crc(&msg[0..11]));
    */

    /*
    // crc is as expected for any kind of data packet
    let mut msg: Vec<u8>;
    msg = vec![0x5E, 0x35, 0x83, 0x7E, 0x22, 0x18, 0xB2];
    println!("crc = {:#02X}", crc(&msg, Some(SHORT_MSG_BITS)));
    // explicitly set bits size
    assert_eq!(crc(&msg, Some(SHORT_MSG_BITS)), 0x2218B2);
    // automatically determine bits size
    assert_eq!(crc(&msg, None), 0x2218B2);
    */

    let mut data: Vec<u8>;
    data = vec![143, 77, 32, 35, 88, 127, 52, 94, 53, 131, 126, 34, 24, 178];
    // explicitly set bits size
    assert_eq!(checksum_compare(&data, Some(LONG_MSG_BITS)), true);
    // automatically determine bits size
    assert_eq!(checksum_compare(&data, None), true);

    // Tests pulled from https://github.com/flightrac/modes-crc/blob/master/test/crc_checker.js
    // test valid checksum for short message
    data = vec![0x5D, 0x4D, 0x20, 0x23, 0x7A, 0x55, 0xA6]; // 40, 0, 16, 36, 220, 121, 76
    assert_eq!(checksum(&data, Some(SHORT_MSG_BITS)), 0x7A55A6);

    // test invalid checksum for short message
    data = vec![0x28, 0x00, 0x10, 0x24, 0xDC, 0x79, 0x4C]; // 40, 0, 16, 36, 220, 121, 76
    assert_eq!(checksum_compare(&data, Some(SHORT_MSG_BITS)), false);

    // test valid checksum for long message
    data = vec![0x8F, 0x4D, 0x20, 0x23, 0x58, 0x7F, 0x34, 0x5E, 0x35, 0x83, 0x7E, 0x22, 0x18, 0xB2]; // 143, 77, 32, 35, 88, 127, 52, 94, 53, 131, 126, 34, 24, 178
    assert_eq!(checksum(&data, Some(LONG_MSG_BITS)), 0x2218B2);

    // test crc is as expected for any kind of data packet
    data = vec![0x28, 0x00, 0x10, 0x24, 0xDC, 0x79, 0x4C];
    assert_eq!(crc(&data, Some(SHORT_MSG_BITS)), 0xDC794C);

    // test passing an invalid frame returns an error
    data  = vec![0x06];
    assert_eq!(checksum(&data, None), 0);

    // test get message bits length from data frame size
    data = vec![0x5D, 0x4D, 0x20, 0x23, 0x7A, 0x55, 0xA6];
    assert_eq!(checksum(&data, None), 0x7A55A6);
    //////////////////// END CHECKSUM VALIDATION TEST SECTION

    // Connect to the server
    let result = TcpStream::connect("127.0.0.1:4000");
    match result {
        Ok(mut stream) => {
            debug!("Successfully connected to the server at 127.0.0.1:4000");
            // Spawn a new thread to handle the connection
            thread::spawn(move || {
                if let Err(e) = handle_connection(&mut stream) {
                    eprintln!("Error handling connection: {}", e);
                }
            });

            // Keep the main thread alive while the connection thread does its work
            // This is a simple way to keep the program running for demonstration purposes
            loop {
                thread::park();
            }
        }
        Err(e) => {
            error!("Failed to connect to the server: {}", e);
        }
    }
}
*/
