extern crate log;

use clap::{command, Parser};
use clap::error::ErrorKind;
use clap::CommandFactory;
use log::{LevelFilter};
use log::{trace, debug, info, warn, error};
use env_logger::Builder;
use std::str::FromStr;

use std::sync::mpsc;
use std::thread;
use std::time::Duration;

use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::{TcpListener, TcpStream};
use tokio::task;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
//#[group(args = ["lat", "lon", "alt"], required = false)]
#[clap(group(
    clap::ArgGroup::new("Receiver location")
        .required(false)
        .multiple(true)
        .args(&["lat", "lon", "alt"]),
))]
#[clap(group(
    clap::ArgGroup::new("Multilateration server connection")
        .required(false)
        .multiple(true)
        .args(&["user", "server", "no_udp"]),
))]
struct Cli {
  // Sets the latitude
  #[arg(short = None, long = "lat", action, env = "MLAT_LAT", help = "Latitude of the receiver, in decimal degrees. Required.")]
  lat: u32,

  // Sets the longitude
  #[arg(short = None, long = "lon", action, env = "MLAT_LON", help = "Longitude of the receiver, in decimal degrees. Required.")]
  lon: u32,

  // Sets the altitude
  #[arg(short = None, long = "alt", action, env = "MLAT_ALT", help = "Altitude of the receiver (height above ellipsoid). Required. Defaults to metres, but units may be specified with a 'ft' or 'm' suffix. (Except if they're negative).")]
  alt: u32,

  // Sets the privacy flag
  #[arg(short = None, long = "privacy", action = clap::ArgAction::SetTrue, default_value_t = false, env = "MLAT_PRIVACY", help = "Sets the privacy flag for this receiver. Currently, this removes the receiver location pin from the coverage maps.")]
  privacy: bool,

  // Sets the user
  #[arg(short = None, long = "user", action, env = "MLAT_USER", help = "User information to give to the server. Used to get in touch if there are problems.")]
  user: String,

  // Sets the server 
  #[arg(short = None, long = "server", action, env = "MLAT_SERVER", help = "host:port of the multilateration of the server to connect to")]
  server: String,

  // Sets the no UDP flag
  #[arg(short = None, long = "no-udp", action = clap::ArgAction::SetFalse, default_value_t = true, env = "MLAT_NO_UDP", help = "Don't offer to use UDP transport for sync/mlat messages")]
  no_udp: bool,


  // Manage debugging information
  #[arg(short = 'v', long = "log-level", alias = "loglevel", action = clap::ArgAction::Set, default_value_t = String::from("info"), value_parser = ["off", "error", "warn", "info", "debug", "trace"], env = "BLADERF_ADSB_LOG_LEVEL", help = "Log level")]
  log_level: String,
  #[arg(short = None, long = "log-style", alias = "logstyle", action = clap::ArgAction::Set, default_value_t = String::from("auto"), value_parser = ["auto", "always", "never"], env = "BLADERF_ADSB_LOG_STYLE", help = "Manage color for log messages")]
  log_style: String,
}

// References:
// https://docs.rs/clap/latest/clap/enum.ArgAction.html
#[tokio::main]
async fn main() -> tokio::io::Result<()> {
    let cli = Cli::parse();

    // setup logging
    let mut builder = Builder::new();
    builder.filter_level(LevelFilter::from_str(cli.log_level.as_str()).unwrap());
    builder.parse_write_style(cli.log_style.as_str());
    builder.init();

    //let remote: bool = cli.remote.clone();
    
    println!("{:?}", cli);
    let address: &str;
    let port: &str;
    let vec_server: Vec<&str> = cli.server.split(':').collect();
    match vec_server.as_slice() {
        [a, p] => {
            address = a;
            port = p;
        },
        _ => {
            let mut cmd = Cli::command();
            cmd.error(
                ErrorKind::InvalidValue,
                "Server should be in 'host:port' format"
            ).exit();
        }
    }
    info!("address = {}; port = {}", address, port);

    error!("error");
    warn!("warn");
    info!("info");
    debug!("debug");
    trace!("trace");

    /*
    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
    */

    // Start the server task.
    let server_handle = task::spawn(async {
        run_server("127.0.0.1:8080").await
    });

    // Start the client task.
    let client_handle = task::spawn(async {
        run_client("127.0.0.1:8080").await
    });

    // Wait for both server and client to complete.
    let _ = tokio::try_join!(server_handle, client_handle);

    Ok(())
}

/// Runs the server that listens on the specified address.
async fn run_server(addr: &str) -> tokio::io::Result<()> {
    // Bind the server to the specified address.
    let listener = TcpListener::bind(addr).await?;
    println!("Server running on {}", addr);

    loop {
        // Accept incoming connections.
        let (mut socket, _) = listener.accept().await?;

        // Spawn a new task to handle the connection.
        task::spawn(async move {
            let mut buf = [0; 1024];

            // Read data from the socket.
            match socket.read(&mut buf).await {
                Ok(n) if n == 0 => return, // Connection was closed.
                Ok(n) => {
                    println!("Received: {}", String::from_utf8_lossy(&buf[..n]));
                    // Echo the data back to the client.
                    if let Err(e) = socket.write_all(&buf[..n]).await {
                        println!("Failed to write to socket: {}", e);
                    }
                }
                Err(e) => {
                    println!("Failed to read from socket: {}", e);
                }
            }
        });
    }
}

/// Runs the client that connects to the specified address.
async fn run_client(addr: &str) -> tokio::io::Result<()> {
    // Connect to the server.
    let mut stream = TcpStream::connect(addr).await?;
    println!("Client connected to {}", addr);

    // Send a message to the server.
    let msg = "Hello from client!";
    stream.write_all(msg.as_bytes()).await?;
    println!("Client sent: {}", msg);

    // Read the server's response.
    let mut buf = [0; 1024];
    let n = stream.read(&mut buf).await?;
    println!("Client received: {}", String::from_utf8_lossy(&buf[..n]));

    Ok(())
}

    //ctrlc::set_handler(move || {
    //  debug!("received Ctrl+C!");
    //})
    //.expect("Error setting Ctrl-C handler");
