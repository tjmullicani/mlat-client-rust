/*
 * Part of mlat-client-rust (https://github.com/tjmullicani/mlat-client-rust) - an ADS-B multilateration client.
 * Based on mlat-client (https://github.com/mutability/mlat-client)
 * Copyright 2023, Timothy Mullican <timothy.j.mullican@gmail.com>
 * Copyright 2015, Oliver Jowett <oliver@mutability.co.uk>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

use std::net::{Ipv4Addr, TcpStream, UdpSocket};
use std::io::{BufReader, BufRead, Write};
use std::time::{SystemTime, UNIX_EPOCH};
use tokio::sync::mpsc;
use mpsc::Sender;
use mpsc::Receiver;
use tokio::task;

use clap::{command, Parser};
use clap::error::ErrorKind;
use clap::CommandFactory;
use log::LevelFilter;
use log::{trace, debug, info, warn, error};
use env_logger::Builder;
use std::str::FromStr;
use std::collections::HashSet;

extern crate log;
extern crate hex_slice;
use hex_slice::AsHex;

mod modes;
use crate::modes::modes_reader::*;
use crate::modes::modes_message::*;
// use crate::modes::modes::*;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
//#[group(args = ["lat", "lon", "alt"], required = false)]
#[clap(group(
    clap::ArgGroup::new("Receiver location")
        .required(false)
        .multiple(true)
        .args(&["lat", "lon", "alt"]),
))]
#[clap(group(
    clap::ArgGroup::new("Multilateration server connection")
        .required(false)
        .multiple(true)
        .args(&["user", "server", "no_udp"]),
))]
struct Cli {
  // Sets the latitude
  #[arg(short = None, long = "lat", action, env = "MLAT_LAT", help = "Latitude of the receiver, in decimal degrees. Required.")]
  lat: u32,

  // Sets the longitude
  #[arg(short = None, long = "lon", action, env = "MLAT_LON", help = "Longitude of the receiver, in decimal degrees. Required.")]
  lon: u32,

  // Sets the altitude
  #[arg(short = None, long = "alt", action, env = "MLAT_ALT", help = "Altitude of the receiver (height above ellipsoid). Required. Defaults to metres, but units may be specified with a 'ft' or 'm' suffix. (Except if they're negative).")]
  alt: u32,

  // Sets the privacy flag
  #[arg(short = None, long = "privacy", action = clap::ArgAction::SetTrue, default_value_t = false, env = "MLAT_PRIVACY", help = "Sets the privacy flag for this receiver. Currently, this removes the receiver location pin from the coverage maps.")]
  privacy: bool,

  // Sets the user
  #[arg(short = None, long = "user", action, env = "MLAT_USER", help = "User information to give to the server. Used to get in touch if there are problems.")]
  user: String,

  // Sets the server 
  #[arg(short = None, long = "server", action, env = "MLAT_SERVER", help = "host:port of the multilateration of the server to connect to")]
  server: String,

  // Sets the no UDP flag
  #[arg(short = None, long = "no-udp", action = clap::ArgAction::SetFalse, default_value_t = true, env = "MLAT_NO_UDP", help = "Don't offer to use UDP transport for sync/mlat messages")]
  no_udp: bool,


  // Manage debugging information
  #[arg(short = 'v', long = "log-level", alias = "loglevel", action = clap::ArgAction::Set, default_value_t = String::from("info"), value_parser = ["off", "error", "warn", "info", "debug", "trace"], env = "BLADERF_ADSB_LOG_LEVEL", help = "Log level")]
  log_level: String,
  #[arg(short = None, long = "log-style", alias = "logstyle", action = clap::ArgAction::Set, default_value_t = String::from("auto"), value_parser = ["auto", "always", "never"], env = "BLADERF_ADSB_LOG_STYLE", help = "Manage color for log messages")]
  log_style: String,
}

/// Emulates time.monotonic() if not available.
fn monotonic_time() -> f64 {
    static mut ADJUST: f64 = 0.0;
    static mut LAST: f64 = 0.0;

    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Failed to get system time")
        .as_secs_f64();

    unsafe {
        if now < LAST {
            ADJUST += LAST - now;
        }
        LAST = now;
        now + ADJUST
    }
}

async fn receive_data_tcp(tx: Sender<HashSet<ModesMessage>>) {
    warn!("receive_data_tcp run");
    let mut stream = TcpStream::connect("127.0.0.1:30005").unwrap();
    //let mut stream = TcpStream::connect("172.16.11.51:30005").unwrap();

    // Array with a fixed size
    let mut reader = BufReader::new(stream);
    let mut received: Vec<u8> = Vec::new();
    let mut total_received_bytes = 0;
    let mut last_received = monotonic_time();
    let mut m = ModesReader::default();
    m.set_decoder_mode(DecoderMode::Beast);

    loop {
        warn!("receive_data_tcp loop");
        // Read from the current data in the TcpStream
        received = reader.fill_buf().unwrap().to_vec();

        // If no data is received, the connection might have been closed
        if received.is_empty() {
            println!("No data received. Connection might be closed.");
            break;
        }

        let frames = m.feed_beast(received.clone());
        // Assuming `frames` is defined as a tuple (HashSet<ModesMessage>, bool)
        //let frames: (HashSet<modes_message::ModesMessage>, bool) = (HashSet::new(), true);

        // Destructure the tuple to get the HashSet
        let (frame_set, _flag) = frames;

        for frame in &frame_set {
            println!("new frame");
            println!("---------");
            println!("frame.timestamp: {}", frame.timestamp);
            println!("frame.signal: {}", frame.signal);
            println!("frame.df: {}", frame.df);
            println!("frame.nuc: {}", frame.nuc);
            println!("frame.even_cpr: {}", frame.even_cpr);
            println!("frame.odd_cpr: {}", frame.odd_cpr);
            println!("frame.valid: {}", frame.valid);
            println!("frame.crc: {}", frame.crc);
            println!("frame.address: {}", frame.address);
            println!("frame.altitude: {}", frame.altitude);
            println!("frame.data: {:#02X}", frame.data.as_hex());
            println!("frame.datalen: {}", frame.datalen);
            println!("frame.eventdata: {:?}", frame.eventdata);
            //////////////////////////
            // println!("frame.message_type: {:#02X}", frame.message_type);
            // println!("frame.message_length: {}", frame.message_length);
            // println!("frame.timestamp: {}", frame.timestamp);
            // println!("frame.signal_level: {}", frame.signal_level);
            // println!("frame.message: {:#02X}", frame.message.as_hex());
            // if frame.message_type == MESSAGE_TYPE_MODE_S || frame.message_type == MESSAGE_TYPE_MODE_L {
            //     if let Some(message) = &frame.message_parsed {
            //         println!("frame.message_parsed:");
            //         println!("---------------------");
            //         println!("{}", message.to_string());
            //     } else {
            //         println!("frame.message_parsed: error");
            //     }
            // }
            println!("");
        }

        if let Err(_) = tx.send(frame_set.clone()).await {
            println!("receiver dropped");
            return;
        }

        reader.consume(received.len());
    }
}

#[tokio::main]
async fn main() -> tokio::io::Result<()> {
    let cli = Cli::parse();

    // setup logging
    let mut builder = Builder::new();
    builder.filter_level(LevelFilter::from_str(cli.log_level.as_str()).unwrap());
    builder.parse_write_style(cli.log_style.as_str());
    builder.init();

    //let remote: bool = cli.remote.clone();
    
    if !cli.server.contains(':') {
        let mut cmd = Cli::command();
            cmd.error(
                ErrorKind::InvalidValue,
                "Server should be in 'host:port' format"
            ).exit();
    }
    let dest_address: String = cli.server;
    info!("address = {}", dest_address);

    // error!("error");
    // warn!("warn");
    // info!("info");
    // debug!("debug");
    // trace!("trace");

    //let (tx, mut rx): (Sender<ModesReader>, Receiver<ModesReader>) = mpsc::channel(100);
    let (tx, mut rx): (Sender<HashSet<ModesMessage>>, Receiver<HashSet<ModesMessage>>) = mpsc::channel(100);
    //std::thread::spawn(|| receive_data_tcp(tx));
    //receive_data_tcp(tx).await;

    task::spawn_blocking({
        move || {
          tokio::runtime::Handle::current().block_on(
            receive_data_tcp(tx)
          )
        }
      });
    // tokio::task::spawn_blocking(move || receive_data_tcp(tx)).await;
    // tokio::spawn(async move {
    //     fn2(dest_address, rx).await;
    // }).await?;
    task::spawn_blocking({
        move || {
          tokio::runtime::Handle::current().block_on(
            transmit_data(dest_address, rx)
          )
        }
      });

    Ok(())
}

async fn transmit_data(dest_address: String, mut rx: Receiver<HashSet<ModesMessage>>) {
    warn!("transmit_data run");
    let dest_proto = "udp"; // udp or tcp
    //let dest_address = "127.0.0.1:30004";

    if dest_proto == "udp" {
        let socket = UdpSocket::bind((Ipv4Addr::UNSPECIFIED, 0)).unwrap();
        socket.connect(dest_address).unwrap();

        loop {
            trace!("transmit_data loop");
            if let Some(frames) = rx.recv().await {
                for frame in frames {
                    println!("{:#02X}", frame.data.as_hex());
                    // FIXME: for testing, do not print 0x31 type messages
                    //if frame.message_type != 0x31 {
                        let len = socket.send(&frame.data).unwrap();
                        println!("Sent {} bytes", len);
                    //}
                }
            } else {
                break;
            }
        }
    } else if dest_proto == "tcp" {
        let mut socket = TcpStream::connect(dest_address).unwrap();

        loop {
            warn!("transmit_data loop");
            if let Some(frames) = rx.recv().await {
                for frame in frames {
                    println!("{:#02X}", frame.data.as_hex());
                    let len = socket.write(&frame.data).unwrap();
                    println!("Sent {} bytes", len);
                }
            }
        }
    }
}
